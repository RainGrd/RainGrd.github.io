<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java | RainGrd Blog</title><meta name="author" content="RainGrd"><meta name="copyright" content="RainGrd"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面向对象什么是面向对象： 面向对象的方法主要是把事物给对象化，包括其属性和行为。面向对象编程更贴近实际生活的思想。总体来说面向对象的底层还是面向过程，面向过程抽象成类，然后封装，方便使用就是面向对象（万物皆对象） 类与对象关系：类是对象的抽象，对象是类的实例化 面向对象的世界 创建一个类（汽车类） 设置类的属性（汽车的颜色、容量、速度） 设置类的行为（跑）   对象(类的具体的事物)  如何定义类">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="http://example.com/2023/07/21/Java/index.html">
<meta property="og:site_name" content="RainGrd Blog">
<meta property="og:description" content="面向对象什么是面向对象： 面向对象的方法主要是把事物给对象化，包括其属性和行为。面向对象编程更贴近实际生活的思想。总体来说面向对象的底层还是面向过程，面向过程抽象成类，然后封装，方便使用就是面向对象（万物皆对象） 类与对象关系：类是对象的抽象，对象是类的实例化 面向对象的世界 创建一个类（汽车类） 设置类的属性（汽车的颜色、容量、速度） 设置类的行为（跑）   对象(类的具体的事物)  如何定义类">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-07-21T09:29:10.544Z">
<meta property="article:modified_time" content="2023-07-21T09:46:09.524Z">
<meta property="article:author" content="RainGrd">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/21/Java/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-21 17:46:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="RainGrd Blog"><span class="site-name">RainGrd Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-21T09:29:10.544Z" title="发表于 2023-07-21 17:29:10">2023-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-21T09:46:09.524Z" title="更新于 2023-07-21 17:46:09">2023-07-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>什么是面向对象：</p>
<p>面向对象的方法主要是把事物给对象化，包括其属性和行为。面向对象编程更贴近实际生活的思想。总体来说面向对象的底层还是面向过程，面向过程抽象成类，然后封装，方便使用就是面向对象（万物皆对象）</p>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="关系："><a href="#关系：" class="headerlink" title="关系："></a>关系：</h3><p>类是对象的抽象，对象是类的实例化</p>
<h3 id="面向对象的世界"><a href="#面向对象的世界" class="headerlink" title="面向对象的世界"></a>面向对象的世界</h3><ol>
<li>创建一个类（汽车类）<ol>
<li>设置类的属性（汽车的颜色、容量、速度）</li>
<li>设置类的行为（跑）</li>
</ol>
</li>
<li>对象(类的具体的事物)</li>
</ol>
<h3 id="如何定义类"><a href="#如何定义类" class="headerlink" title="如何定义类"></a>如何定义类</h3><ol>
<li>类用class来定义</li>
<li>属性：成员变量描述，直接写在类的变量</li>
<li>动作：成员方法，没有static的方法</li>
<li>对象中的属性是类中定义好的变量</li>
</ol>
<p>类的对象只有有限个，确定的</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><h3 id="this的多种指向"><a href="#this的多种指向" class="headerlink" title="this的多种指向"></a>this的多种指向</h3><ul>
<li>在对象方法中， this 指向调用它所在方法的对象。</li>
<li>单独使用 this，它指向全局(Global)对象。</li>
<li>函数使用中，this 指向函数的所属者。</li>
<li>严格模式下函数是没有绑定到 this 上，这时候 this 是 undefined。</li>
<li>在 HTML 事件句柄中，this 指向了接收事件的 HTML 元素。</li>
<li>apply 和 call 允许切换函数执行的上下文环境（context），即 this 绑定的对象，可以将 this 引用到任何对象。</li>
</ul>
<h3 id="什么是this"><a href="#什么是this" class="headerlink" title="什么是this"></a>什么是this</h3><ol>
<li>this 相当于是指向当前对象本身，等同于“new 类()”</li>
</ol>
<h3 id="this的作用"><a href="#this的作用" class="headerlink" title="this的作用"></a>this的作用</h3><ol>
<li>this可以区分成员变量和局部变量</li>
<li>this可以在方法体里调用对象的属性和信息</li>
<li>this关键字也可以用于在构造函数中调用其他构造函数。但是，只能定义在构造函数的第一行，因为初始化动作要先执行</li>
<li>this关键字可以调用本类的其他构造方法</li>
</ol>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="什么是构造方法"><a href="#什么是构造方法" class="headerlink" title="什么是构造方法"></a>什么是构造方法</h3><p>在创建对象的时候，自动调用的方法</p>
<p>语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 类名(传参)&#123;</span><br><span class="line">  <span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>没有返回值</li>
<li>与类同名</li>
<li>在我们执行new的时候，自动调用无参构造方法</li>
<li>Java会默认给每一个类设置无参构造方法，但是，如果我们设置有参构造方法的话，则系统不在赠送了！</li>
</ol>
<h3 id="构造方法的作用"><a href="#构造方法的作用" class="headerlink" title="构造方法的作用"></a>构造方法的作用</h3><ol>
<li>在创建对象时，可以给对象设置属性信息</li>
</ol>
<h3 id="构造方法的重载"><a href="#构造方法的重载" class="headerlink" title="构造方法的重载"></a>构造方法的重载</h3><p>好处：</p>
<ol>
<li>可以让我们有更多的方式创建对象</li>
<li>提高了效率</li>
<li>改变函数的数据类型不会影响重载</li>
<li>只改变函数的参数的个数和参数的数据类型</li>
</ol>
<h2 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h2><p>static:静态</p>
<p>静态的内容在内存中是保留一份的，并且各个对象之间进行共享</p>
<p>访问static的方式：使用类名点这个静态变量</p>
<p>特点：</p>
<ol>
<li>数据共享</li>
<li>属于类的并不属于对象</li>
<li>优先于对象产生的</li>
</ol>
<p>static关键字的用途</p>
<ol>
<li>方便在没有创建对象的情况下来进行调用（方法&#x2F;变量)</li>
<li>静态变量的数据被本类中所有实例对象所共享</li>
<li>如果该静态变量的访问权限高于private，则该静态变量可通过“类名.变量名”直接访问</li>
<li>在java中，被static修饰的代码块被称作静态代码块。静态代码块在类被加载时，就会被执行，并且只会执行一次（类只会加载一次）</li>
</ol>
<p>注意事项：</p>
<ol>
<li>由于创建对象的过程是在静态内容加载完成之后，在静态方法和静态方法里不可以使用this关键字</li>
<li>类中的常量一般也是static修饰的</li>
<li>static关键字一般不用于在构造器使用，不利于维护代码</li>
</ol>
<p>构造器的优先级：static构造器&gt;通用构造器&gt;构造方法</p>
<h2 id="包和导包"><a href="#包和导包" class="headerlink" title="包和导包"></a>包和导包</h2><p>包名的命名方式：域名反写，示例：com.域名.包名</p>
<p>导包：import 包+类;</p>
<p>注意事项</p>
<ol>
<li>在本包里面，调用其他类，是不需要导包的</li>
<li>Java.lang包下的所有内容都不需要导包</li>
</ol>
<h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>公共的,所有人都可以用</p>
<h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>包访问权限，只有自己包里可以被访问的</p>
<h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>用法：用来隐藏类的实现细节和保护类的数据。 </p>
<p>注意事项</p>
<ol>
<li>类和接口不能为private</li>
<li>private定义的变量只能通过类中公共的geter方法访问</li>
</ol>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>优点</p>
<ol>
<li>良好的封装能够减少代码的复合率</li>
<li>类内部的结构可以自由修改</li>
<li>可以对成员变量进行更精确的控制</li>
<li>隐藏信息，实现细节</li>
</ol>
<p>setter方法：主要是对成员变量赋值，做一定的保护</p>
<p>getter方法：从成员变量中获取数据，</p>
<p>idea快速生成getter和setter的方法：</p>
<ol>
<li>鼠标右击”Generate”</li>
<li>点击”Getter and Setter”,</li>
<li>将定义的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E6%AE%B5&spm=1001.2101.3001.7020">字段</a>全部选中,点击OK</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>什么是继承：子类可以拥有父类中除了私有内容外的其他所有内容</p>
<p>继承的使用场景：当出现x是一种y的时候，x就可以继承y</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：</p>
<ol>
<li>简化代码</li>
</ol>
<p>Java继承类型</p>
<p> <img src="https://www.runoob.com/wp-content/uploads/2013/12/java-extends-2020-12-08.png" alt="img"> </p>
<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><h3 id="super的作用"><a href="#super的作用" class="headerlink" title="super的作用"></a>super的作用</h3><ol>
<li>对父类成员的访问，用来引用当前对象的父类</li>
<li>可以调用父类中的构造方法，必须写在子类构造方法的第一行，但是如果父类的构造方法是无参数的，可以不写，如果父类没有无参数的构造， 要super</li>
</ol>
<h3 id="super与this关键字的区别"><a href="#super与this关键字的区别" class="headerlink" title="super与this关键字的区别"></a>super与this关键字的区别</h3><p>this用于优先调用当前类的变量</p>
<p>super用于调用父类的变量</p>
<p>this和super可以区分父类和子类中重名的变量</p>
<p>创建对象的过程中，先创建父类的对象，然后再创建子类的对象 </p>
<h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><h3 id="什么是重写"><a href="#什么是重写" class="headerlink" title="什么是重写"></a>什么是重写</h3><p>子类对父类中的方法进行重新定义</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>子类和父类中的方法的声明完全一致</p>
<h3 id="重写的概念"><a href="#重写的概念" class="headerlink" title="重写的概念"></a>重写的概念</h3><p>子类的方法覆盖父类的方法</p>
<h3 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h3><ul>
<li>参数列表与被重写方法的参数列表必须完全相同。</li>
<li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类(子类)（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为 final 的方法不能被重写。</li>
<li>声明为 static 的方法不能被重写，但是能够被再次声明。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>
<li>构造方法不能被重写。</li>
<li>如果不能继承一个类，则不能重写该类的方法</li>
<li>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="什么是多态："><a href="#什么是多态：" class="headerlink" title="什么是多态："></a>什么是多态：</h3><p>同一个对象拥有多种形态</p>
<h3 id="多态的作用："><a href="#多态的作用：" class="headerlink" title="多态的作用："></a>多态的作用：</h3><ol>
<li>把不同的数据类型进行统一，让程序拥有超强的可拓展性</li>
<li>消除类型之间的耦合关系</li>
<li>可替换性</li>
<li>可扩充性</li>
<li>接口性</li>
<li>灵活性</li>
<li>简化性</li>
</ol>
<h3 id="多态的理解"><a href="#多态的理解" class="headerlink" title="多态的理解"></a>多态的理解</h3><p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，</p>
<p>即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，</p>
<p>这样做的好处：不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>多态性增强了软件的灵活性和扩展性</p>
<h3 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h3><ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象：Parent p &#x3D; new Child();</li>
</ul>
<h3 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h3><ol>
<li><p>把子类的对象赋值给父类的变量 -&gt; 向上转型</p>
<p>缺点：会屏蔽掉子类特有的方法</p>
</li>
<li><p>把父类的变量转化会子类的变量 -&gt; 向下转型</p>
<p>为何需要向下转型：向上转型会屏蔽掉子类特有的方法</p>
<p>知识点：在无法进行强转 时，可以根据instanceof关键字进行判断</p>
<p>局限性：向下转型，可能需要强转数据类型</p>
</li>
</ol>
<p>代码示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      show(<span class="keyword">new</span> <span class="title class_">Cat</span>());  <span class="comment">// 以 Cat 对象调用 show 方法</span></span><br><span class="line">      show(<span class="keyword">new</span> <span class="title class_">Dog</span>());  <span class="comment">// 以 Dog 对象调用 show 方法</span></span><br><span class="line">                </span><br><span class="line">      <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  <span class="comment">// 向上转型  </span></span><br><span class="line">      a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">      <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;        <span class="comment">// 向下转型  </span></span><br><span class="line">      c.work();        <span class="comment">// 调用的是 Cat 的 work</span></span><br><span class="line">  &#125;  </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Animal a)</span>  &#123;</span><br><span class="line">      a.eat();  </span><br><span class="line">        <span class="comment">// 类型判断</span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)  &#123;  <span class="comment">// 猫做的事情 </span></span><br><span class="line">            <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog) &#123; <span class="comment">// 狗做的事情 </span></span><br><span class="line">            <span class="type">Dog</span> <span class="variable">c</span> <span class="operator">=</span> (Dog)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;抓老鼠&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;吃骨头&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;看家&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">吃鱼</span></span><br><span class="line"><span class="comment">抓老鼠</span></span><br><span class="line"><span class="comment">吃骨头</span></span><br><span class="line"><span class="comment">看家</span></span><br><span class="line"><span class="comment">吃鱼</span></span><br><span class="line"><span class="comment">抓老鼠</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="什么是重载"><a href="#什么是重载" class="headerlink" title="什么是重载"></a>什么是重载</h3><p>是在一个类里，方法名字相同，而参数不同，返回类型相同也可以不同</p>
<h3 id="重载的规则"><a href="#重载的规则" class="headerlink" title="重载的规则"></a>重载的规则</h3><ul>
<li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载。</li>
<li>无法以返回值类型作为重载函数的区分标准</li>
</ul>
<h3 id="重载的好处"><a href="#重载的好处" class="headerlink" title="重载的好处"></a>重载的好处</h3><ul>
<li>重载也是多态性的体现：一个内容，可以实现多个功能</li>
<li>在调用的时候，可以使用相同名字（一个名字）的方法实现不同的功能。</li>
<li>在定义时：使用相同的方法名（一个方法）来表示功能相同的（多个）方法。</li>
</ul>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bdqn.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 段荣贵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下两个参数类型顺序不同</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(<span class="type">int</span> a,String s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;returntest3&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String s,<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;returntest4&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Job</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Job</span>();</span><br><span class="line">        System.out.println(o.test());</span><br><span class="line">        o.test(<span class="number">1</span>);</span><br><span class="line">        System.out.println(o.test(<span class="number">1</span>,<span class="string">&quot;test3&quot;</span>));</span><br><span class="line">        System.out.println(o.test(<span class="string">&quot;test4&quot;</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重写与重载之间的区别"><a href="#重写与重载之间的区别" class="headerlink" title="重写与重载之间的区别"></a>重写与重载之间的区别</h3><p><img src="/Java.assets/1647433324252.png" alt="1647433324252"></p>
<ol>
<li>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li>
<li>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li>
<li>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li>
</ol>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>定义：</p>
<p>final是一个关键字 可以用于修饰类，成员变量，成员方法 </p>
<p>特点</p>
<ol>
<li>它修饰的类不能被继承。</li>
<li>它修饰的成员变量是一个常量。是不可以被改变的</li>
<li>它修饰的成员方法是不能被子类重写的</li>
</ol>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>定义：现实中不存在的东西</p>
<p>在Java中表示：只声明，不实现</p>
<p>注意事项</p>
<ol>
<li>抽象类不能被实例化，只有非抽象类子类可以创建对象</li>
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类一定是抽象类</li>
<li>通过抽象类可以强制的要求子类中必须有哪些方法</li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能</li>
<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 </li>
<li>抽象类的子类必须重写父类中的抽象方法，除非该子类也是抽象类</li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>定义：接口实际上是一种特殊的抽象类，接口中的所有方法都是抽象方法</p>
<p>接口的声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名] &#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特性</p>
<ul>
<li>接口是隐式抽象的，当声明一个接口的时候，不必使用<strong>abstract</strong>关键字。</li>
<li>接口中每一个方法也是隐式抽象的，声明时同样不需要<strong>abstract</strong>关键字。</li>
<li>接口中的方法都是公有的。并且都是抽象方法</li>
</ul>
<h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<ul>
<li>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。 </li>
<li>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。 </li>
<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li>
<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li>
<li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法 </li>
<li>一个类可以同时实现多个接口。但是只能继承一个类</li>
<li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li>
</ul>
<h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>注意事项</p>
<ul>
<li><p>Java中，类的多继承是不合法的，接口允许多继承</p>
</li>
<li><p>抽象类能够继承非抽象的类</p>
</li>
<li><p>在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口</p>
</li>
</ul>
<p>  代码示例</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hockey</span> <span class="keyword">extends</span> <span class="title class_">Sports</span>, Event</span><br><span class="line"><span class="comment">//接口允许多继承，而 Sports及 Event 可以定义或是继承相同的方法</span></span><br></pre></td></tr></table></figure>


<h3 id="接口与类的区别"><a href="#接口与类的区别" class="headerlink" title="接口与类的区别"></a>接口与类的区别</h3><ul>
<li>类只能单继承，接口支持多继承</li>
<li>接口不能用于实例化对象</li>
<li>接口没有构造方法</li>
<li>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。</li>
<li>接口不能包含成员变量，除了 static 和 final 变量。</li>
<li>接口不是被类继承了，而是要被类实现</li>
</ul>
<h3 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h3><ol>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口</li>
</ol>
<h2 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object(对象)"></a>Object(对象)</h2><p>定义： Java Object 类是所有类的父类,也就是说 Java 的所有类都继承了 Object,子类可以使用 Object 的所有方法 </p>
<p>实例方法</p>
<p><img src="/Java.assets%5C1647434767123.png" alt="1647434767123"></p>
<h2 id="equals和"><a href="#equals和" class="headerlink" title="equals和&#x3D;&#x3D;"></a>equals和&#x3D;&#x3D;</h2><p>&#x3D;&#x3D;用于判断左右两端的数据是否一致，也就是比较两个变量的内存地址，一般用于比较基本数据类型</p>
<p>equals:object提供的一个方法，用来判断两个对象是否相等，在字符串中，equals是被重写了，其作用是用于比较两个字符中的内容是否一致</p>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bdqn.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 段荣贵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        String str1=&quot;小红&quot;;</span></span><br><span class="line"><span class="comment">//        String str2=&quot;小红&quot;; //str2并没有单独占用内存，反而是与str1共同占用一个对象</span></span><br><span class="line"><span class="comment">//        System.out.println(str1==str2);</span></span><br><span class="line"><span class="comment">//        System.out.println(str1.equals(str2));</span></span><br><span class="line">        String str3=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;钢精&quot;</span>);</span><br><span class="line">        String str4=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;钢精&quot;</span>);</span><br><span class="line">        <span class="comment">/*由于双等于号中是判断内存地址是否一致，而new String()会创建一个String的对象，</span></span><br><span class="line"><span class="comment">        而不是一个String类型的变量*/</span></span><br><span class="line">        System.out.println(str3==str4); <span class="comment">//false</span></span><br><span class="line">        <span class="comment">/*字符串的equals方法是被重写的，他这里面只是判断了两个字符串的内容是否一致*/</span></span><br><span class="line">        System.out.println(str3.equals(str4));  <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//注意事项</span></span><br><span class="line">        <span class="comment">/*字符串的判断必须要用equals方法判断内容*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Instanceof关键字"><a href="#Instanceof关键字" class="headerlink" title="Instanceof关键字"></a>Instanceof关键字</h2><p>定义： 测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Integer);<span class="comment">//编译不通过</span></span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Object);<span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure>

<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><ol>
<li>规定一个类应该有且仅有一个引起他变化的原因，否则类应该被拆分</li>
<li>优点：消除耦合，减小因需求变化引起代码僵化</li>
</ol>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><ol>
<li>软件实体应当对扩展开放，对修改关闭</li>
<li>降低了程序各部分之间的耦合性，其适应性、灵活性、稳定性都比较好。当已有软件系统需要增加新的功能时，不需要对作为系统基础的抽象层进行修改，只需要在原有基础上附加新的模块就能实现所需要添加的功能。增加的新模块对原有的模块完全没有影响或影响很小，这样就无须为原有模块进行重新测试 </li>
<li>使用场景：封装、接口、重载</li>
</ol>
<h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><ol>
<li>子类可以完全替换父类，不会影响程序的运行</li>
<li>一般用于抽象类继承</li>
</ol>
<h3 id="依赖倒换原则"><a href="#依赖倒换原则" class="headerlink" title="依赖倒换原则"></a>依赖倒换原则</h3><ol>
<li><p>设计类的时候，我们要用抽象来思考，而不是具体化每个类</p>
</li>
<li><p>高层模块不应该依赖底层模块，两者都应该依赖其抽象；</p>
</li>
</ol>
<p>   抽象不应该依赖细节；</p>
<p>   细节应该依赖抽象；</p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><ol>
<li>将大的接口打散成多个小接口，让系统解耦，从而容易重构，更改和重新部署</li>
<li>客户端不应该依赖那些他不需要的接口，避免接口太大，违背接口隔离原则，或者接口太小会系统接口泛滥，不利于维护</li>
</ol>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>优先使用对象组合，而不是继承来达到复用的目的</p>
<p> <img src="https://img-blog.csdnimg.cn/20200407131808895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F0dTExMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p> 每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义：位于外部类成员位置的类 </p>
<p>特点：可以使用外部类中所有的成员变量和成员方法</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">      <span class="comment">//成员位置</span></span><br><span class="line">      <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">              System.out.println(age);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ​</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] ages)</span> &#123;</span><br><span class="line">          <span class="comment">//成员内部类是非静态的演示</span></span><br><span class="line">          Outer.<span class="type">Inner</span> <span class="variable">oi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">          oi.show();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>创建对象时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员内部类不是静态的：</span></span><br><span class="line">  外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类名.new 内部类名();</span><br><span class="line"><span class="comment">//成员内部类是静态的：</span></span><br><span class="line">  外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类名.内部类名();    </span><br></pre></td></tr></table></figure>

<p>成员内部类常见的修饰符</p>
<p>private</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">              System.out.println(“密码备份文件”);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//使用getXxx()获取成员内部类，可以增加校验语句（文中省略）</span></span><br><span class="line">      <span class="keyword">public</span> Inner <span class="title function_">getInner</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">          Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.getInner();</span><br><span class="line">          inner.show();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>static：静态内部类</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义：定义在一个方法或者一个作用域的类</p>
<p>特点：主要是作用域发生了变化</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><h3 id="泛化-Generalization"><a href="#泛化-Generalization" class="headerlink" title="泛化(Generalization)"></a>泛化(Generalization)</h3><p>定义：一种继承关系，指定了子类如何转化父类的所有特征和行为</p>
<p>箭头指向：空心三角形的实线</p>
<p>示例图：</p>
<p> <img src="https://img-blog.csdn.net/20180716154732958?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTM4Nzg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"> </p>
<h3 id="实现-Realization"><a href="#实现-Realization" class="headerlink" title="实现(Realization)"></a>实现(Realization)</h3><p>定义：类与接口的关系，表示类是接口中所有特征和行为的实现</p>
<p>箭头指向：空心三角形的虚线</p>
<p>示例图：</p>
<p> <img src="https://img-blog.csdn.net/20180716155344309?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTM4Nzg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"> </p>
<h3 id="关联-Association"><a href="#关联-Association" class="headerlink" title="关联(Association)"></a>关联(Association)</h3><p>定义：是一种拥有的关心。他使一个类知道另一个类的属性和方法</p>
<p>代码体现：成员变量</p>
<p>箭头指向：普通箭头的实线</p>
<p>示例图：</p>
<p> <img src="https://img-blog.csdn.net/201807161559133?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTM4Nzg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"> </p>
<p>一般时期，类与类之间是双向关联，但是，有时候类与类之间可能是单向关联。比如，一名学生可能要上多门课程，但是课程且不一定拥有学生，这个时候，就要用到自身关联</p>
<p>示例图</p>
<p> <img src="https://img-blog.csdn.net/20180716160314655?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTM4Nzg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"> </p>
<h3 id="聚合-Aggregation"><a href="#聚合-Aggregation" class="headerlink" title="聚合(Aggregation)"></a>聚合(Aggregation)</h3><p>定义：是整体和部分的关系,且部分可以离开整体而单独存在</p>
<p>里氏代换原则:子类可以代替父类,不会影响程序的运行</p>
<p>例子：车和轮胎是整体和部分的关系,轮胎离开车仍然可以存在。但是车就不一定了</p>
<p>箭头指向：空心菱形的实线，菱形指向整体</p>
<p>示例图：</p>
<p> <img src="https://img-blog.csdn.net/20180716160920404?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTM4Nzg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"> </p>
<h3 id="组合-Composition"><a href="#组合-Composition" class="headerlink" title="组合(Composition)"></a>组合(Composition)</h3><p>定义： 是整体与部分的关系，但部分不能离开整体而单独存在</p>
<p>例子： 是整体与部分的关系，但部分不能离开整体而单独存在</p>
<p>箭头指向:</p>
<p> <img src="https://img-blog.csdn.net/20180716161243615?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTM4Nzg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"> </p>
<h3 id="依赖-Dependency"><a href="#依赖-Dependency" class="headerlink" title="依赖(Dependency)"></a>依赖(Dependency)</h3><p>定义：是一种使用的关系，即一个类的实现需要里一个类的协助，所以尽量不使用双向的互相依赖</p>
<p>箭头指向：带普通箭头的虚线</p>
<h3 id="各种关系的强弱顺序"><a href="#各种关系的强弱顺序" class="headerlink" title="各种关系的强弱顺序"></a>各种关系的强弱顺序</h3><p> 泛化（类与继承关系） &#x3D; 实现（类与接口关系） &gt; 组合（整体与部分的关系） &gt; 聚合（整体与部分的关系） &gt; 关联（拥有的关系） &gt; 依赖（使用的关系） </p>
<p> <img src="https://img-blog.csdn.net/20180716163727865?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTM4Nzg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"> </p>
<h1 id="Java基础类库"><a href="#Java基础类库" class="headerlink" title="Java基础类库"></a>Java基础类库</h1><p>基本数据类型包装类的示例图</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装器类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody></table>
<p>注意事项：</p>
<ol>
<li>Integer，Byte，Float，Double，Short，Long都属于Number类的子类</li>
<li>Character属于Object子类</li>
<li>Boolean属于Object子类</li>
</ol>
<h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><p>创建Integer构造方法的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);    <span class="comment">//以int型变量作为参数创建Integer对象</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;123&quot;</span>);      <span class="comment">//以String型变量作为参数创建Integer对象</span></span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<p>使用String型队参数创建Integer对象时，字符创的值必须是数值型的如“123”，否则会抛出异常</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">功能说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byteValue()</td>
<td align="center">byte</td>
<td align="center">以byte型返回Integer的值</td>
</tr>
<tr>
<td align="center">shortValue()</td>
<td align="center">short</td>
<td align="center">以short型返回Integer的值</td>
</tr>
<tr>
<td align="center">intValue()</td>
<td align="center">int</td>
<td align="center">以int型返回Integer的值</td>
</tr>
<tr>
<td align="center">toString()</td>
<td align="center">String</td>
<td align="center">返回一个表示该Integer值的String对象</td>
</tr>
<tr>
<td align="center">toBinaryString(int i)</td>
<td align="center">String</td>
<td align="center">将一个正整数转换成2进制字符串</td>
</tr>
<tr>
<td align="center">toOctalString(int i)</td>
<td align="center">String</td>
<td align="center">将一个正整数转换成8进制字符串</td>
</tr>
<tr>
<td align="center">toHexString(int i)</td>
<td align="center">String</td>
<td align="center">将一个正整数转换成16进制字符串</td>
</tr>
<tr>
<td align="center">valueOf(String s)</td>
<td align="center">Integer</td>
<td align="center">返回保存指定的String值的Integer对象</td>
</tr>
<tr>
<td align="center">parseInt(String s)</td>
<td align="center">int</td>
<td align="center">将数字字符串转换为int型的数值</td>
</tr>
<tr>
<td align="center">equals(Object obj)</td>
<td align="center">boolean</td>
<td align="center">比较此对象与指定对象是否相等</td>
</tr>
<tr>
<td align="center">compareTo(IntegeranothInteger)</td>
<td align="center">int</td>
<td align="center">在数字上比较两个Integer对象，如果相等，则返回0；<br />如果调用对象的数值小于anothInteger的数值，则返回负值；<br />如果调用对象的数值大于anothInteger的数值，则返回正值</td>
</tr>
</tbody></table>
<h2 id="基本数据类型、包装类与String之间的装换"><a href="#基本数据类型、包装类与String之间的装换" class="headerlink" title="基本数据类型、包装类与String之间的装换"></a>基本数据类型、包装类与String之间的装换</h2><h2 id="单元测试方法"><a href="#单元测试方法" class="headerlink" title="单元测试方法"></a>单元测试方法</h2><p>如何使用单元测试方法</p>
<p>idea：</p>
<ol>
<li><p>安装JUnit插件 </p>
<p> File–&gt;settings–&gt;Plguins–&gt;Browse repositories–&gt;输入JUnit–&gt;选择JUnit Generator V2.0安装</p>
</li>
<li><p>使用JUnit插件</p>
<p>在需要进行单元测试的类中，使用快捷键alt+insert，选择JUnit test，选择JUnit4。</p>
</li>
</ol>
<p>注意事项</p>
<ol>
<li>测试方法上面必须使用@Test注解进行修饰。　　　</li>
<li>测试方法必须使用public void 进行修饰，不能带有任何参数</li>
<li>新建一个源代码目录用来存放测试代码。</li>
<li>测试类的包应该与被测试类的包保持一致。</li>
<li>测试单元中的每一个方法必须独立测试，每个测试方法之间不能有依赖。</li>
<li>测试类使用Test做为类名的后缀（非必要）。</li>
<li>测试方法使用test作为方法名的前缀（非必要）。</li>
</ol>
<p>错误解析</p>
<ol>
<li>Failure 一般是单元测试使用的断言方法判断失败引起，说明预期结果和程序运行结果不一致。</li>
<li>error 是有代码异常引起的，他产生于测试代码本身中的Bug。</li>
<li>测试用例是不是用来证明你是对的，而是用来证明你没有错</li>
</ol>
<h2 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h2><p>常用方法</p>
<p> <img src="https://img2020.cnblogs.com/blog/2105136/202010/2105136-20201014224325176-1419192071.png" alt="img"> </p>
<h2 id="Number类"><a href="#Number类" class="headerlink" title="Number类"></a>Number类</h2><p>定义：Number类是一个抽象类，也是一个超类，所有的包装类(Double,Float,Byte,Short,Integer,Long);</p>
<p>注意事项：抽象类不能直接实例化，而是必须实例化具体的子类</p>
<p>Number的常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>byte byteValue();</td>
<td>返回 byte 类型的值</td>
</tr>
<tr>
<td>double doubleValue();</td>
<td>返回 double 类型的值</td>
</tr>
<tr>
<td>float floatValue();</td>
<td>返回 float 类型的值</td>
</tr>
<tr>
<td>int intValue();</td>
<td>返回 int 类型的值</td>
</tr>
<tr>
<td>long longValue();</td>
<td>返回 long 类型的值</td>
</tr>
<tr>
<td>short shortValue();</td>
<td>返回 short 类型的值</td>
</tr>
</tbody></table>
<p>System类</p>
<p>注意事项：该类的构造方法是private的，所以无法创建该类的对象，也是就是无法实例化</p>
<p>三个静态成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> InputStream in;</span><br><span class="line"><span class="comment">//标准输入流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream out;</span><br><span class="line"><span class="comment">//标准输出流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> PrintStream err;</span><br><span class="line"><span class="comment">//标准错误流</span></span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<p>arraycopy():数组复制</p>
<p>currentTimeMillis():放回当前的计算机时间[以当前计算机时间，与GMT 1970所差的毫秒数]</p>
<p>exit()：用于终止当前正在运行的Java虚拟机</p>
<p>gc()：请求系统进行回收垃圾，清除内存</p>
<p>getProperty():获得系统中属性名为key属性对应的值</p>
<h2 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h2><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>基本语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000L</span>);</span><br><span class="line"><span class="comment">// 默认创建一个本地时间, long类型</span></span><br><span class="line"><span class="comment">// Date date = new Date(System.currentTimeMillis());</span></span><br><span class="line"><span class="comment">// 从1970-1-1 0:0:0开始</span></span><br><span class="line"><span class="comment">//输出打印时间</span></span><br><span class="line">System.out.println(date1);</span><br><span class="line"><span class="comment">// 打印出北京时间 Thu Jan 01 08:00:01 CST 1970</span></span><br><span class="line">System.out.println(date1.toGMTString());</span><br><span class="line"><span class="comment">// 打印出格林标准时间 1 Jan 1970 00:00:01 GMT</span></span><br><span class="line"><span class="comment">//输出时差</span></span><br><span class="line"><span class="comment">// 返回与格林时间的时差, 以分钟计时, 正好是8个小时, 此函数输出-480   则北京时间-480分钟等于格林时间</span></span><br><span class="line">date1.getTimezoneOffset();</span><br><span class="line"><span class="comment">//打印毫秒数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> date1.getTime();</span><br><span class="line"><span class="comment">// 打印出date到1970年1月1日的毫秒数</span></span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m);</span><br><span class="line"><span class="comment">// 比较时间</span></span><br><span class="line"><span class="comment">// 返回boolean类型</span></span><br><span class="line">date.after(date1);</span><br><span class="line">date.before(date1);</span><br><span class="line"><span class="comment">// 返回-1 1 0</span></span><br><span class="line">date.compareTo(date1);</span><br><span class="line"><span class="comment">//SimpleDateFormat使用(用于转换Date类)</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// 指定格式输出时间</span></span><br><span class="line"><span class="comment">// yyyy 年   MM 月   dd日   h 12小时制   H  24小时制0-23   ss秒     SSS毫秒</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss.SSS&quot;</span>);</span><br><span class="line"><span class="comment">//SimpleDateFormat(&quot;正则表达式&quot;)</span></span><br><span class="line">System.out.println(dateFormat.format(date));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定格式的字符串转化成Date</span></span><br><span class="line"><span class="comment">// &quot;2018-05-26 09:03:22.658&quot;</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">dateFormat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   date = dateFormat1.parse(<span class="string">&quot;2018-05-26 09:03:22.658&quot;</span>);</span><br><span class="line">   <span class="comment">// 输出 date = Sat May 26 09:03:22 CST 2018</span></span><br><span class="line">   System.out.println(<span class="string">&quot;date = &quot;</span> + date);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置日历时间</span></span><br><span class="line">calendar.set(Calendar.YEAR, <span class="number">2019</span>);</span><br><span class="line">calendar.set(Calendar.MONTH, <span class="number">5</span>);</span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH, <span class="number">26</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Date类设置calendar时间(需要使用SimpleDateFormat先将Date进行转换才可以设置)</span></span><br><span class="line">calendar.setTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得日历时间 calendar.getTime();  返回一个Date对象</span></span><br><span class="line"><span class="comment">// 输出Wed Jun 26 12:58:42 CST 2019</span></span><br><span class="line">System.out.println(calendar.getTime().toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用日历取得时间偏移</span></span><br><span class="line"><span class="comment">// 输出Tue Jun 26 12:58:42 CST 2029</span></span><br><span class="line">calendar.add(Calendar.YEAR, <span class="number">10</span>);</span><br><span class="line">System.out.println(calendar.getTime().toString());</span><br></pre></td></tr></table></figure>

<h2 id="java8-新特性—java-time包-时间处理类"><a href="#java8-新特性—java-time包-时间处理类" class="headerlink" title="java8 新特性—java.time包 时间处理类"></a>java8 新特性—java.time包 时间处理类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LocalDate类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 本地日期</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2019</span>, <span class="number">2</span>, <span class="number">14</span>);</span><br><span class="line">System.out.println(localDate);</span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> localDate.getYear(); <span class="comment">//那一年</span></span><br><span class="line">System.out.println(<span class="string">&quot;year = &quot;</span> + year);</span><br><span class="line"><span class="type">Month</span> <span class="variable">month</span> <span class="operator">=</span> localDate.getMonth(); <span class="comment">// 第几个月</span></span><br><span class="line">System.out.println(<span class="string">&quot;month = &quot;</span> + month);</span><br><span class="line"><span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> localDate.getDayOfMonth(); <span class="comment">//一个月的第几天</span></span><br><span class="line">System.out.println(<span class="string">&quot;dayOfMonth = &quot;</span> + dayOfMonth);</span><br><span class="line"><span class="type">DayOfWeek</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> localDate.getDayOfWeek(); <span class="comment">//一周的第几天</span></span><br><span class="line">System.out.println(<span class="string">&quot;dayOfWeek = &quot;</span> + dayOfWeek);</span><br><span class="line"><span class="type">int</span> <span class="variable">lenth</span> <span class="operator">=</span> localDate.lengthOfMonth(); <span class="comment">// 一个月的天数</span></span><br><span class="line">System.out.println(<span class="string">&quot;lenth = &quot;</span> + lenth);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">leapYear</span> <span class="operator">=</span> localDate.isLeapYear(); <span class="comment">// 是否是闰年</span></span><br><span class="line">System.out.println(<span class="string">&quot;leapYear = &quot;</span> + leapYear);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前日期</span></span><br><span class="line">System.out.println(<span class="string">&quot;LocalDate.now() = &quot;</span> + LocalDate.now());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LocalTime类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// LocalTime 包含具体时间</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.of(<span class="number">22</span>, <span class="number">10</span>, <span class="number">59</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;localTime = &quot;</span> + localTime);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LocalDateTime类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// LocalDateTime包括LocalDate和LocalTime</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(localDate, localTime);</span><br><span class="line">System.out.println(<span class="string">&quot;localDateTime = &quot;</span> + localDateTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//LocalDateTime 和 LocalDate, LocalTime 相互转换</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> localDateTime.toLocalDate();</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">localTime1</span> <span class="operator">=</span> localDateTime.toLocalTime();</span><br><span class="line"><span class="comment">// 时间加减操作</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate2</span> <span class="operator">=</span> date.minusDays(<span class="number">5</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate3</span> <span class="operator">=</span> date.plusYears(<span class="number">10</span>);</span><br><span class="line">date.plus(<span class="number">5</span>, ChronoUnit.DAYS);</span><br><span class="line">System.out.println(<span class="string">&quot;localDate3 = &quot;</span> + localDate3);</span><br><span class="line">System.out.println(<span class="string">&quot;localDate2 = &quot;</span> + localDate2);</span><br></pre></td></tr></table></figure>

<h2 id="Instant类的使用"><a href="#Instant类的使用" class="headerlink" title="Instant类的使用"></a>Instant类的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"><span class="comment">/*格林威治时间*/</span></span><br><span class="line">System.out.println(instant);</span><br><span class="line"><span class="comment">/*中国北京时间*/</span></span><br><span class="line">System.out.println(instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>)));</span><br><span class="line"><span class="comment">/*获取对应的毫秒数*/</span></span><br><span class="line">System.out.println(instant.toEpochMilli());</span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="comment">Instant instant1 = Instant.ofEpochMilli(1648438049886L);</span></span><br><span class="line"><span class="comment">System.out.println(instant1);</span></span><br></pre></td></tr></table></figure>

<h2 id="DateTimeFormatter"><a href="#DateTimeFormatter" class="headerlink" title="DateTimeFormatter"></a>DateTimeFormatter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*方式一：*/</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">forMatter</span> <span class="operator">=</span> DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">LocalDateTime now=LocalDateTime.now();</span><br><span class="line"><span class="comment">//格式化:日期--&gt;字符串</span></span><br><span class="line">String str=forMatter.format(now);</span><br><span class="line">System.out.println(str);</span><br><span class="line">System.out.println(now);</span><br><span class="line"><span class="comment">/*解析：字符串--&gt;日期*/</span></span><br><span class="line"><span class="type">TemporalAccessor</span> <span class="variable">parse</span> <span class="operator">=</span> forMatter.parse(<span class="string">&quot;2022-03-28T11:39:19.788&quot;</span>);</span><br><span class="line">System.out.println(parse);</span><br><span class="line"><span class="comment">/*方式二：本地化，一般适用于*/</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter1</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">String str2=formatter1.format(now);</span><br><span class="line">System.out.println(str2);</span><br><span class="line"><span class="comment">/*FormatStyle.LONG\FormatStyle.MEDIUM\FormatStyle.SHORT\FormatStyle.FULL*/</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter2</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM);</span><br><span class="line">String str3=formatter2.format(now);</span><br><span class="line">System.out.println(str3);</span><br><span class="line"><span class="comment">/*重点：方式三：自定义*/</span></span><br><span class="line">DateTimeFormatter formatter3=DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">/*格式化*/</span></span><br><span class="line">String str4=formatter3.format(now);</span><br><span class="line">System.out.println(str4);</span><br><span class="line"><span class="comment">/*转换*/</span></span><br><span class="line"><span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> formatter3.parse(<span class="string">&quot;2022-03-28 02:27:43&quot;</span>);</span><br><span class="line">System.out.println(accessor);</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2022-03-28T14:28:45.287</span></span><br><span class="line"><span class="comment">2022-03-28T14:28:45.287</span></span><br><span class="line"><span class="comment">&#123;&#125;,ISO resolved to 2022-03-28T11:39:19.788</span></span><br><span class="line"><span class="comment">2022年3月28日 下午02时28分45秒</span></span><br><span class="line"><span class="comment">2022-3-28</span></span><br><span class="line"><span class="comment">2022-03-28 02:28:45</span></span><br><span class="line"><span class="comment">&#123;MinuteOfHour=27, MilliOfSecond=0, NanoOfSecond=0, HourOfAmPm=2, SecondOfMinute=43, MicroOfSecond=0&#125;,ISO resolved to 2022-03-28</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="枚举的使用场所"><a href="#枚举的使用场所" class="headerlink" title="枚举的使用场所"></a>枚举的使用场所</h2><ol>
<li>当需要定义一组常量时</li>
<li>类的对象只是有限个，确定的</li>
</ol>
<h2 id="枚举的使用"><a href="#枚举的使用" class="headerlink" title="枚举的使用"></a>枚举的使用</h2><p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 标识符 </span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">//枚举数据表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>常用方法</p>
<p> <img src="https://img-blog.csdnimg.cn/20210107100842973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5eXJoZg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bdqn.job.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: duan.rong.gui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/28 20:11:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 枚举类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PizzaStatus</span> <span class="keyword">implements</span> <span class="title class_">IPizzaStatus</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法作用：用于判断是否预定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ORDERED(<span class="number">5</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOrdered</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法作用：用于判断是否准备就绪</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    READY(<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法作用：派送成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DELIVERED(<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDelivered</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> timeToDelivery;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法作用：创建构造方法:初始化数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PizzaStatus(<span class="type">int</span> timeToDelivery)&#123;</span><br><span class="line">        <span class="built_in">this</span>.timeToDelivery = timeToDelivery;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*预定*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOrdered</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法作用：是否准备准备就绪</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> false</span></span><br><span class="line"><span class="comment">     * 方法作用：判断是否派送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDelivered</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> timeToDelivery</span></span><br><span class="line"><span class="comment">     * 方法作用：获取派送时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTimeToDelivery</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeToDelivery;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPizzaStatus</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isOrdered</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDelivered</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bdqn.job.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: duan.rong.gui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/28 20:07:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 披萨</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pizza</span>&#123;</span><br><span class="line">    <span class="comment">/*定义：Pizza的状态*/</span></span><br><span class="line">    <span class="keyword">private</span> PizzaStatus status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> status</span></span><br><span class="line"><span class="comment">     * 获取状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> PizzaStatus <span class="title function_">getStatus</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *方法作用：设置状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(PizzaStatus status)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> flag</span></span><br><span class="line"><span class="comment">     * 是否派送成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDeliverable</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/**/</span></span><br><span class="line"><span class="comment">        if (this.status.isReady() || this.status.isOrdered() || this.status.isDelivered()) &#123;</span></span><br><span class="line"><span class="comment">            flag=true;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return flag;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    /**</span></span><br><span class="line"><span class="comment">     * 方法作用：打印输出披萨的派送状态和派送时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printTimeTODeliver</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isDeliverable()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Time to delivery is &quot;</span>+<span class="built_in">this</span>.getStatus().getTimeToDelivery());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;并未派送&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bdqn.job.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: duan.rong.gui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/28 20:37:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 主方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pizza</span>();</span><br><span class="line">        <span class="comment">/*根据披萨的派送状态，返回派送时间*/</span></span><br><span class="line">        pizza.setStatus(PizzaStatus.READY);</span><br><span class="line">        pizza.printTimeTODeliver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用枚举的注意事项"><a href="#使用枚举的注意事项" class="headerlink" title="使用枚举的注意事项"></a>使用枚举的注意事项</h2><ol>
<li>值一般是大写，且都是整数</li>
<li>用逗号隔开</li>
<li>枚举类型可以进行比较</li>
</ol>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>泛型的本质是参数化类型，所操作的数据类型被指定为一个参数</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul>
<li>类型安全</li>
<li>消除强制类型的转换</li>
<li>提高代码的复用率</li>
</ul>
<h2 id="常用的泛型标识"><a href="#常用的泛型标识" class="headerlink" title="常用的泛型标识"></a>常用的泛型标识</h2><ul>
<li>E - Element (在集合中使用，因为集合中存放的是元素)</li>
<li>T - Type（表示Java 类，包括基本的类和我们自定义的类）</li>
<li>K - Key（表示键，比如Map中的key）</li>
<li>V - Value（表示值）</li>
<li>N - Number（表示数值类型）</li>
<li>？ - （表示不确定的java类型）</li>
<li>S、U、V - 2nd、3rd、4th types</li>
</ul>
<p>注意事项</p>
<ol>
<li>泛型类不支持基本数据类型</li>
<li>如果泛型类没有指定类型，默认会按照Object来操作</li>
<li>同一泛型类，根据不同的数据类型创建的对象，本质上是同一对象</li>
</ol>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型类的定义语法</span></span><br><span class="line">class 类名称&lt;泛型标识,泛型标识,...&gt;&#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 变量名;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用语法</span></span><br><span class="line">类名&lt;具体的数据类型&gt; 对象名=<span class="keyword">new</span> 类名&lt;具体的数据类型(jdk <span class="number">1.7</span>可以省略了)&gt;();</span><br></pre></td></tr></table></figure>

<p>派生子类</p>
<ul>
<li><p>如果子类也是泛型类，那么子类与父类的泛型类型要一致</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChildGeneric</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Generic</span> &lt;T&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子类不是泛型类，父类要明确泛型的数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChildGeneric</span> <span class="keyword">extends</span> <span class="title class_">Generic</span>&lt;String&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名称 &lt;泛型标识，泛型标识，…&gt; &#123;</span><br><span class="line">	泛型标识 方法名(); </span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型接口的使用</p>
<ul>
<li>实现类不是泛型类，接口要明确数据类型</li>
<li>实现类也是泛型类，实现类和接口的泛型类型一致</li>
</ul>
<p>注意</p>
<ol>
<li>如果不指定泛型类接口的参数类型，默认为Object，否则一定要指定参数类型</li>
<li>实现泛型接口的类不明确声明泛型类型</li>
<li>泛型不允许实例化</li>
</ol>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">访问权限 &lt;泛型参数&gt; 返回类型 方法名(参数列表)&#123;</span><br><span class="line">  方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型方法与普通方法的区别</p>
<ol>
<li>泛型参数写在访问权限和返回类型之间，表示在方法中应用泛型，需要在调用时确定</li>
<li>泛型方法可以声明为static方法</li>
</ol>
<h2 id="通配符和有界限制"><a href="#通配符和有界限制" class="headerlink" title="通配符和有界限制"></a>通配符和有界限制</h2><p>常用的通配符</p>
<ul>
<li><p>?:无边界通配符，一般用于指定具体的类型实参</p>
</li>
<li><? extends A>:泛型的上边界，表示泛型类型可以是A及其子类

要求：该泛型的类型，只能是实参类型，或实参类型的子类类型
</li>
<li><? super A>: 泛型的下边界，表示泛型类型可以是A及其父类</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>定义：单列集合类的根接口，规定了逐一存放数据。</p>
<p>List、Set是继承Collection的两个重要接口，List的特点是存放的元素都是有序且重复的，Set的特点是存放的与元素是无序且不可以重复的</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>boolean add(E ele):将给定的参数对象增加到集合对象里面，</p>
<p>boolean addAll():将指定集合中的所有元素添加到此集合</p>
<p>int hashcode():返回此集合中哈希吗值</p>
<p>int size()：返回此集合中的元素个数</p>
<p>boolean isEmpty:如果此集合不包含元素，则返回true</p>
<p>viod clear:清空集合内容(元素设置为null),容器size设置为0</p>
<p>boolean remove(Object obj):从此集合中移除指定元素，如果此集合中包含一个或多个元素，则移除所有这样的元素，返回true</p>
<p>Object [] toArray:返回一个包含此集合中所有元素的数组</p>
<h3 id="Collection的遍历"><a href="#Collection的遍历" class="headerlink" title="Collection的遍历"></a>Collection的遍历</h3><h4 id="1-使用Iterator迭代器遍历集合"><a href="#1-使用Iterator迭代器遍历集合" class="headerlink" title="1.使用Iterator迭代器遍历集合"></a>1.使用Iterator迭代器遍历集合</h4><p>常用方法:</p>
<p>boolean hasNext():如果仍有元素可以迭代，则返回true</p>
<p>放回指针后是否有元素，在遍历集合元素的需要先调用hasNext()方法判断指针是否指向集合的末尾</p>
<p>E next:返回下一个元素</p>
<ol>
<li>取出下一个元素</li>
<li>指针向后移动一位</li>
</ol>
<p>void remove():删除迭代器返回的最后一个元素</p>
<p>注意事项</p>
<ol>
<li>当集合类对象调用iterator()方法创建迭代器，会把指针(索引)赋值为-1，即在指针指向第一个元素的之前</li>
<li>迭代遍历只能用remove()方法删除元素，不能直接通过迭代器对容器内元素的内容进行修改</li>
</ol>
<h4 id="2-foreach遍历集合"><a href="#2-foreach遍历集合" class="headerlink" title="2.foreach遍历集合"></a>2.foreach遍历集合</h4><p>局限性：他只能用来遍历集合，而不能对集合元素进行修改或删除</p>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>定义：是一种有序、可重复的容器，这里的有序是指数据线性存储，可以根据元素的索引进行访问，存储的对象允许重复</p>
<ol>
<li><p>ArrayList：</p>
<p>可变长度数组，支持存储所有元素，包括null,适合于根据位置对集合元素进行快速的随机访问，但增删元素的速度较慢，不支持线程同步，底层是Object[]存储</p>
</li>
<li><p>LinkedList：</p>
<p>底层使用双向列表存储对象，适合于向集合中插入和删除对象，使用效率大于ArrayList，但不适合随机访问集合中的元素，不支持多线程同步</p>
</li>
<li><p>Vector：</p>
<p>底层也是可变数组存储，支持线程同步，因此效率低于ArrayList</p>
</li>
</ol>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><p>特点：无序且不可重复的，无序是指Set集合中的元素没有索引，只能通过遍历获得指定元素，</p>
<p>注意事项：</p>
<ol>
<li>HashSet底层使用哈希表存储，如果存储数据没有存储数据，则添加成功，反之用equals()方法进行判断相等，如果在存储自定义对象时，一定要重写该类的hashCode()和equals()方法，避免对象相等判断</li>
<li>Set里面全是Collection定义过的方法</li>
<li>Set的无序:不等于无序性</li>
</ol>
<p>分类：</p>
<ol>
<li>HashSet:Set接口中的主要实现类：线程不安全，效率高</li>
<li>LinkedHashSet：HashSet的子类，遍历其内部数据可以按照添加的顺序遍历，每个数据还维护两个引用，记录此数据前一个数据和后一个数据：对于频繁的遍历操作，效率要比HaseSet要高</li>
<li>TreeSet：使用红黑树添加的结构存储数据的，可以按照添加对象的指定属性进行排序</li>
</ol>
<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>定义：双列集合类的根接口，存放的数据是键值对的，一个key对应一个value,其中key是无序且不可以重复的，value是有序的且可以重复的</p>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>添加、修改、删除操作</td>
<td></td>
</tr>
<tr>
<td>Object put(K key,V value)</td>
<td>存放键值对</td>
</tr>
<tr>
<td>void putAll(Map m)</td>
<td>从指定Map对象中将所有映射关系复值到此Map对象中</td>
</tr>
<tr>
<td>Object remove(K key)</td>
<td>删除指定key的key-value键值对，并返回value值</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空当前Map对象的数据重置为null，size重置为0</td>
</tr>
<tr>
<td>元素查询操作</td>
<td></td>
</tr>
<tr>
<td>boolean containsKey(K key)</td>
<td>如果此Map对象包含指定键的映射关系，则返回true</td>
</tr>
<tr>
<td>boolean containsValue(V  value)</td>
<td>如果此Map对象将一个或多个键映射到指定值，则返回true</td>
</tr>
<tr>
<td>int size()</td>
<td>返回当前Map对象中键值映射个数</td>
</tr>
<tr>
<td>boolean equals(Object obj)</td>
<td>比较指定的对象与此Map对象是否相等</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>如果此Map对象未包含键值映射关系，则返回true</td>
</tr>
<tr>
<td>Object get(K k)</td>
<td>返回指定键对应的值;如果Map对象中不包括键 k 则返回null</td>
</tr>
<tr>
<td>与视图相关的操作</td>
<td></td>
</tr>
<tr>
<td>Set entrySet()</td>
<td>返回此Map对象中包含的映射关系的Set视图</td>
</tr>
<tr>
<td>Set keySet()</td>
<td>返回此Map对象中包含的键的Set视图</td>
</tr>
<tr>
<td>Collection values()</td>
<td>返回此Map对象中包含的值的Collection视图</td>
</tr>
</tbody></table>
<h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><ul>
<li>HashMap：底层使用哈希表存储数据，在查找、修改和删除等方面都有非常高的效率，也是最常用的一种Map集合类</li>
<li>TreeMap：底层通过红黑树实现，TreeMap会自动排序，存储的Key 必须实现Comparable接口</li>
<li>HashTable:底层也是使用哈希表进行存储，支持线程同步</li>
<li>Propertiess：读取Java的配置文件，在Java中其配置文件常为.properties文件，是以键值对的形式进行参数配置</li>
</ul>
<p>Map.entry的主要方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>K getKey()</td>
<td>返回当前Entry的键</td>
</tr>
<tr>
<td>V getValue()</td>
<td>返回当前Entry的值</td>
</tr>
<tr>
<td>V setValue(V vlaue)</td>
<td>修改当前Entry的value的值，并返回修改后的值</td>
</tr>
</tbody></table>
<h2 id="Java集合框架体系图"><a href="#Java集合框架体系图" class="headerlink" title="Java集合框架体系图"></a>Java集合框架体系图</h2><p> <img src="https://img2018.cnblogs.com/i-beta/1853852/202002/1853852-20200213213606650-720589294.png" alt="img"> </p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>定义：指的是程序运行过程中，发生不被期望的事件或出现的非正常的情况，最终导致JVM的非正常停止</p>
<h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><ol>
<li>抛出异常</li>
<li>捕获异常</li>
</ol>
<h2 id="异常类的层次结构"><a href="#异常类的层次结构" class="headerlink" title="异常类的层次结构"></a>异常类的层次结构</h2><p> <img src="https://img-blog.csdn.net/20180920165502957?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pY2hhZWxnbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"> </p>
<h2 id="常见的异常："><a href="#常见的异常：" class="headerlink" title="常见的异常："></a>常见的异常：</h2><ol>
<li>NullPointerExceotion(空指针异常)</li>
<li>ArrayIndexOutOfBounds(数组越界异常)</li>
<li>ArithmeticException(算术异常)</li>
<li>ClassCastException(类型转换异常)</li>
<li>NumberFormatException(数字格式异常)</li>
</ol>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>系统自动处理异常</p>
<p>使用try-catch-finally语句捕获异常</p>
<p>语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//可能会发生异常的程序块</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类<span class="number">1</span> 异常<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">//异常处理程序 1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类<span class="number">2</span> 异常<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">//异常处理程序2</span></span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">finally</span>]&#123;</span><br><span class="line">  <span class="comment">//最终处理程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>若try块中没有发生异常，一般先执行try块中的语法然后执行finally的语句，最后执行try-catch-finally语句后面的语句</li>
<li>若try块中发生了异常，而且此异常在方法内被捕获，在这种情况下，Java首先执行try块中的语句，直到产生异常处，当产生的异常找到了第一个与之相匹配的catch子句时，就跳过try块中剩余的语句，执行捕获此异常的catch子句，若此catch子句中的代码没有产生异常，则执行完相应的catch语句后，程序恢复执行，但不会回到异常发生处继续执行</li>
<li>finally子句是为异常处理提供一个清理机制一般用于释放系统资源</li>
<li>若try块中的发生异常，try-catch-finally语句就会自动在try块中后面的各个catch中找出与该异常相匹配的参数，当参数符合下列条件之一时，就认为这个参数与产生的异常相匹配<ol>
<li>参数与产生的异常属于一个类</li>
<li>参数是产生异常的父类</li>
<li>参数是一个接口时，产生的异常实现这一接口</li>
</ol>
</li>
<li>如果多个catch的异常类之间存在继承关系，则将父类异常写在后面，子类异常写在前面，否则子类所在的catch块将会执行不到</li>
</ol>
<p>使用throw语句抛出异常</p>
<p>语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;方法名称&gt;([&lt;参数行&gt;])<span class="keyword">throws</span> &lt;异常类<span class="number">1</span>&gt;,&lt;异常类<span class="number">2</span>&gt;,...&#123;</span><br><span class="line">  <span class="comment">//方法体语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>throws是在向上一级声明抛出异常，调用的方法使用try-catch捕获异常，或者再用throws声明给再上一级调用的方法，如果方法使用throw声明，则将有Java虚拟机捕获并进行处理</li>
<li>重写方法是异常程序注意的问题：子类在重写父类抛出异常的方法，要么不抛出异常,要门抛出与父类方法相同的异常或该异常的子类</li>
</ol>
<h2 id="异常类及其主要方法"><a href="#异常类及其主要方法" class="headerlink" title="异常类及其主要方法"></a>异常类及其主要方法</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>Exception():用一个空的信息创建一个新的异常</li>
<li>Exception(String message):用字符串参数message描述异常信息，创建一个新的异常</li>
<li>Exception(String message,Throwable cause):用字符串参数massage描述异常信息，参数cause描述异常信创建一个新的异常</li>
<li>Exception(Throwsable cause):用参数cause描述异常信息，创建一个新的异常</li>
</ul>
<h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>String getMessage():返回描述当前异常对象的详细信息</li>
<li>void printStackTrace():在标准流输出设备输出当前异常对象使用堆栈的轨迹，即程序中先后调用了那些方法是程序中产生了这个异常</li>
<li>void printStackTrace(PrintStream s):输出当前异常对象到指定的输出字节流</li>
<li>void printStackTrace(PrintWriter s):输出当前异常对象到指定的输出字符流</li>
<li>String toString():返回描述当前异常对象信息的字符串</li>
</ul>
<h2 id="使用throw语句抛出异常"><a href="#使用throw语句抛出异常" class="headerlink" title="使用throw语句抛出异常"></a>使用throw语句抛出异常</h2><p>语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;方法名称&gt;([&lt;参数行&gt;])<span class="keyword">throws</span> &lt;异常类<span class="number">1</span>&gt;,&lt;异常类<span class="number">2</span>&gt;,...&#123;</span><br><span class="line">  <span class="keyword">if</span>(异常条件<span class="number">1</span>成立)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> 异常类<span class="number">1</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(异常条件<span class="number">2</span>成立)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> 异常类<span class="number">2</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java流"><a href="#Java流" class="headerlink" title="Java流"></a>Java流</h1><p>定义：源中支持聚合操作的一系列元素 </p>
<h2 id="Java流的分类"><a href="#Java流的分类" class="headerlink" title="Java流的分类"></a>Java流的分类</h2><p>按流向流：</p>
<p>输入流：程序可以从中读取数据的流</p>
<p>输出流：程序能向其中写入数据的流</p>
<p>按数据传输单位分：</p>
<p>字节流：以字节为单位传输数据的流</p>
<p>字符流：以字符为单位传输数据的流</p>
<p>按功能分：</p>
<p>节点流：用于直接操作目的设备的流</p>
<p>过滤流：是对一个已存在的流的链接和封装，通过对数据进行处理为程序提供功能强大、灵活的读写功能</p>
<h2 id="Java输入-输出常用类"><a href="#Java输入-输出常用类" class="headerlink" title="Java输入&#x2F;输出常用类"></a>Java输入&#x2F;输出常用类</h2><ol>
<li>InputStream:继承自InputStream的流都是用于向程序中输入数据的，且数据单位都是字节(8位)</li>
<li>OutputStream:继承自OutputStream的流都是程序用于向外输出数据的，且数据单位都是字节(8位)</li>
<li>Reader: 继承自Reader的流都是用于向程序中输入数据的，且数据单位都是字符(16位)</li>
<li>Writer: 继承自Writer的流都是程序用于向外输出数据的，且数据单位都是字符（16位）</li>
</ol>
<h2 id="Java系统流"><a href="#Java系统流" class="headerlink" title="Java系统流"></a>Java系统流</h2><ol>
<li>System.in:标准输入流，默认设备是键盘</li>
<li>System.out:标准输出流，默认设备是控制台</li>
<li>System.err:标准错误流,默认设备是控制台</li>
</ol>
<h2 id="Java字节流"><a href="#Java字节流" class="headerlink" title="Java字节流"></a>Java字节流</h2><p>IO流：</p>
<ul>
<li>IO：输入&#x2F;输出（InputStream&#x2F;outputStream）</li>
<li>流：一种抽象概念，本质上是数据传输</li>
</ul>
<h3 id="字节输入流-InputStream"><a href="#字节输入流-InputStream" class="headerlink" title="字节输入流(InputStream)"></a>字节输入流(InputStream)</h3><p>常用子类</p>
<ul>
<li>ByteArrayInputStream类：将字节数组转换为字节输入流，从中读取字节</li>
<li>FileInputStream类:从文件中读取数据</li>
<li>PipedInputStream类：连接到一个PipedOutputStream(管道输出流)</li>
<li>SequenceInputStream类：将多个字节输入流串联成一个字节输入流</li>
<li>ObjectInputStream类：将对象序列化</li>
</ul>
<p>常用方法</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int read()</td>
<td>从输入流中读取一个8位的字节并把它装换成0~255的整数，最后并返回整数。如果能返回-1，则表示已经到了输入流的末尾，为了提高I&#x2F;O操作的效率，建议使用read()方法的另外两种形式</td>
</tr>
<tr>
<td align="left">int read(byte[]b)</td>
<td>从输入流中读取字节，保存在参数b指定的字节数组中，用于返回实际读取的字节数，如果能返回-1，则表示已经到了输入流的末尾</td>
</tr>
<tr>
<td align="left">int read(byte [] b,int off,int len)</td>
<td>读取字节，保存字节数组，其中off指定在字节数组中开始保存数据的起始下标， len：指定读取的字节数，该方法用于返回读取的字节流，如果能返回-1，则表示已经到了输入流的末尾</td>
</tr>
<tr>
<td align="left">void close()</td>
<td>关闭输入流，释放资源</td>
</tr>
<tr>
<td align="left">int available()</td>
<td>fanhui 可以从输入流中读取的字节数</td>
</tr>
<tr>
<td align="left">long skip(long n)</td>
<td>从输入流中跳过参数n指定数目的字节，该方法返回跳过的字节数</td>
</tr>
<tr>
<td align="left">void mark(int readLimit)</td>
<td>在输入流的当前位置开始设置标记，参数readLimit则指定了最多被设置标记的字节数</td>
</tr>
<tr>
<td align="left">boolean markSupported()</td>
<td>判断当前输入流是否允许设置标记，是则返回true</td>
</tr>
<tr>
<td align="left">void reset()</td>
<td>将输入流的指针返回到设置标记的起始处</td>
</tr>
</tbody></table>
<p>在使用mark()和reset()方法，需要判断该文件系统是否支持这两个方法</p>
<h3 id="字节输出流-outputStream"><a href="#字节输出流-outputStream" class="headerlink" title="字节输出流(outputStream)"></a>字节输出流(outputStream)</h3><p>常用子类：</p>
<ul>
<li>ByteArrayOnputStream类：想内存缓冲区的字节数组中写入数据</li>
<li>FileInputStream类:向文件中写入数据</li>
<li>PipedOnputStream类：连接到一个PipedIutputStream(管道输入流)</li>
<li>ObjectOnputStream类：将对象序列化</li>
</ul>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int b)</td>
<td>写入一个字节，允许使用表达式，不用强制转换byte型</td>
</tr>
<tr>
<td>void write(byte[] b)</td>
<td>将字节数组所有字节写到输出流中</td>
</tr>
<tr>
<td>void write(byte[] b,int off,int len)</td>
<td>将字节写到输出流中，off:字节数组中开始保存数据的起始下标， len：指定读取的字节数，该方法用于返回读取的字节流，如果能返回-1，则表示已经到了输入流的末尾</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭输出流</td>
</tr>
<tr>
<td>void flush()</td>
<td>可以将缓冲区里面的数据写入输出流，并清空缓冲区</td>
</tr>
</tbody></table>
<h3 id="字节数组输入流"><a href="#字节数组输入流" class="headerlink" title="字节数组输入流"></a>字节数组输入流</h3><p>构造方法</p>
<ul>
<li>ByteArrayInputStream(byte[] buf):创建一个字节数组输入流，字节数组类型的数据源有参数buf指定</li>
<li>ByteArrayInputStream(byte[] buf,int offset,int length):创建一个字节数组的输入流，其中buf指定字节数组的类型的数据源，offset指定在字节数组开始读取数据的起始下标位置，length指定读取的元素个数</li>
</ul>
<h3 id="字节数组输出流"><a href="#字节数组输出流" class="headerlink" title="字节数组输出流"></a>字节数组输出流</h3><p>构造方法</p>
<ul>
<li>ByteArrayOutputStream():创建一个字节数组输出流，输出流缓冲区的初始容量大小为32字节</li>
<li>ByteArrayOutputStream(int size):创建一个字节数组输出流，输出流缓冲区的初始容量大小有参数size决定</li>
</ul>
<h3 id="文件字节输入流"><a href="#文件字节输入流" class="headerlink" title="文件字节输入流"></a>文件字节输入流</h3><p>构造方法</p>
<ul>
<li>FileInputStream(File file):通过打开一个到实际文件的连接创建一个FileInputStream类，该文件通过文件系统中的File对象file指定</li>
<li>FileInputStream(String name)：通过打开一个到实际文件的连接创建一个FileInputStream类，该文件通过文件系统中的路径名name指定</li>
</ul>
<h3 id="文件字节输出流"><a href="#文件字节输出流" class="headerlink" title="文件字节输出流"></a>文件字节输出流</h3><p>构造方法</p>
<ul>
<li>FileOutputStream(File file):创建一个文件字节输出流，参数file指定目标文件</li>
<li>FileOutputStream(File file,boolean append):创建一个文件字节输出流，参数file指定目标文件；append是否将数据添加到目标文件的内容末尾，如果append的值true，则在末尾添加，如果为false，覆盖原有内容，默认值为false；</li>
<li>FileOutputStream(String name):创建一个文件字节输出流，参数name指定目标文件的文件路径信息</li>
<li>FileOutputStream(String name,boolean append):创建一个文件字节输出流，参数name和append的含义同上</li>
</ul>
<p>注意事项：</p>
<ol>
<li>指定目标文件时，目标文件可以不存在</li>
<li>目标文件的名称可以任意的</li>
<li>目标文件的所在目录必须存在，否则会抛出异常</li>
<li>目标文件的名称不能是已存在的目录，否则会抛出异常</li>
</ol>
<h2 id="Java字符流"><a href="#Java字符流" class="headerlink" title="Java字符流"></a>Java字符流</h2><h3 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h3><p>Reader类是所有字符输入流的父类</p>
<p>常用子类</p>
<ul>
<li>CharArrayReader类：将字符数组转换成字符输入流，从中读取字符</li>
<li>StringReader类：将字符串转换成字符输入流，从中读取字符</li>
<li>BufferedReader：为其他字符输入流提供缓冲区</li>
<li>PipedReader：连接到一个PipedWriter</li>
<li>InputStreamReader:将字节输入流装换为字符输入流，可以指定字符编码</li>
</ul>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td><code>read()</code>  读一个字符</td>
</tr>
<tr>
<td>int</td>
<td><code>read(char[] cbuf)</code>  将字符读入数组。</td>
</tr>
<tr>
<td>int</td>
<td><code>read(char[] cbuf,  int off, int len)</code>  将字符读入数组的一部分。</td>
</tr>
<tr>
<td>int</td>
<td><code>read(CharBuffer target)</code>  尝试将字符读入指定的字符缓冲区。</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>ready()</code>  告诉这个流是否准备好被读取。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>reset()</code>  重置流。</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>skip(long n)</code>  跳过字符</td>
</tr>
</tbody></table>
<h3 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h3><p>常用子类</p>
<p>CharArrayWriter：组转换成字符输入流，从中读取字符</p>
<p>StringWriter：将字符串转换成字符输入流，从中读取字符</p>
<p>BufferedWriter：为其他字符输入流提供缓冲区</p>
<p>PipedWriter：连接到一个PipedWriter</p>
<p>InputStreamWriter:将字节输出流装换为字符输出流，可以指定字符编码</p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Writer</code></td>
<td><code>append(char c)</code>  将指定的字符附加到此作者。</td>
</tr>
<tr>
<td><code>Writer</code></td>
<td><code>append(CharSequence csq)</code>  将指定的字符序列附加到此作者。</td>
</tr>
<tr>
<td><code>Writer</code></td>
<td><code>append(CharSequence csq, int start,  int end)</code>  将指定字符序列的子序列附加到此作者。</td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code>close()</code>  关闭流，先刷新。</td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code>flush()</code>  刷新流。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(char[] cbuf)</code>  写入一个字符数组。</td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code>write(char[] cbuf,  int off, int len)</code>  写入字符数组的一部分。</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(int c)</code>  写一个字符</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(String str)</code>  写一个字符串</td>
</tr>
<tr>
<td><code>void</code></td>
<td><code>write(String str,  int off, int len)</code>  写一个字符串的一部分。</td>
</tr>
</tbody></table>
<p>注意事项：</p>
<p>Writer类中的所有方法在出错的情况下，都会引发异常，关闭一个流后，在对其进行操作都会产生错误</p>
<h3 id="字符文件输入流"><a href="#字符文件输入流" class="headerlink" title="字符文件输入流"></a>字符文件输入流</h3><p>FileReader</p>
<p>构造方法：</p>
<ul>
<li>FileReader(File file):再给定要读取数据的文件的情况下,创建一个新的FileReader对象</li>
<li>FileReader(String fileName)：在给定从中读取数据的文件名的情况下创建一个新的FileReader对象，参数filename表示要从中读取数据的文件的名称，表示的是一个文件的完整路径</li>
</ul>
<p>注意事项</p>
<p>在创建一个FileReader对象可能会引发异常，需要捕获异常</p>
<h3 id="字符文件输出流"><a href="#字符文件输出流" class="headerlink" title="字符文件输出流"></a>字符文件输出流</h3><p>构造方法</p>
<ul>
<li>FileWriter(File file):在指定File对象的情况下创建一个FileWriter对象，参数file表示要写入数据的File对象</li>
<li>FileWriter(File file,boolean append):在指定File对象的情况下创建一个FileWriter对象，参数file表示要写入数据的File对象；append是否将数据添加到目标文件的内容末尾，如果append的值true，则在末尾添加，如果为false，写入文件开始处，默认值为true；</li>
<li>FileWriter(String fileName):在指定文件名的情况下创建一个FileWriter对象，参数fileName表示要写入的字符的文件名，表示的是完整路径</li>
<li>FileWriter(String fileName,boolean append):在指定文件名以及写入文件的文职的情况下创建一个FileWriter对象，append是否将数据添加到目标文件的内容末尾，如果append的值true，则在末尾添加，如果为false，写入文件开始处，默认值为true</li>
</ul>
<p>注意事项</p>
<p>创建FileWriter对象会出现异常，需要使用try-catch捕获异常</p>
<h2 id="Java输入-输出流对比"><a href="#Java输入-输出流对比" class="headerlink" title="Java输入&#x2F;输出流对比"></a>Java输入&#x2F;输出流对比</h2><h3 id="字节流和字符流的区别"><a href="#字节流和字符流的区别" class="headerlink" title="字节流和字符流的区别"></a>字节流和字符流的区别</h3><ul>
<li>以Stream结尾的都是字节流，Reader和Writer都是字符流</li>
<li>InputStream是所有字节流的父类，OutputStream是所有自己输出流的父类</li>
<li>Reader是字符输入流的父类，Write是字符输出流的父类</li>
</ul>
<p>字节流常用类如下：</p>
<ul>
<li>文件流：FileOutputStream和FileInputStream</li>
<li>缓冲流：BufferedOutputStream和BufferedInputStream</li>
<li>对象流：ObjectOutputStream和ObjectInputStream</li>
</ul>
<p>字符路常用类如下</p>
<ul>
<li>转换流：InputStreamReader和OutputStreamWriter</li>
<li>缓冲字符流：PrintWriter和BufferedReader</li>
</ul>
<p>字节流和字符流的主要区别如下</p>
<ul>
<li>字节流按字节读写，字符流按字符流读写</li>
<li>字节流适合所有类型文件的数据传输，因为计算机字节(byte)是最小的字节，字符流只能处理纯文本数据</li>
<li>在读写文件时需要对内容进行按行处理，如比较特定字符，处理某一行数据时，一般选择字符流</li>
<li>只是读写文件，与文件内容无关时，一般选择字节流</li>
</ul>
<h3 id="区分输入流和输出流"><a href="#区分输入流和输出流" class="headerlink" title="区分输入流和输出流"></a>区分输入流和输出流</h3><p>从磁盘、网络还是键盘将文件读入内存中都使用InputStream</p>
<p>将文件写到磁盘、网络或者写到屏幕都使用OutStream类</p>
<h2 id="带缓存的输入-输出流"><a href="#带缓存的输入-输出流" class="headerlink" title="带缓存的输入&#x2F;输出流"></a>带缓存的输入&#x2F;输出流</h2><h3 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h3><p>构造方法</p>
<ul>
<li>BufferedInputStream(nputStream in);&#x2F;&#x2F;创建一个带有32个字节的缓冲区</li>
<li>BufferedInputStream(InputStream in,int size);&#x2F;&#x2F;按size指定的大小创建缓冲区</li>
</ul>
<h3 id="BufferedOutpuStream"><a href="#BufferedOutpuStream" class="headerlink" title="BufferedOutpuStream"></a>BufferedOutpuStream</h3><p>构造方法</p>
<ul>
<li>BufferedOutputStream(OutputStream os);&#x2F;&#x2F;创建一个带有32个字节的缓冲区</li>
<li>BufferedOutputStream(OutputStream os,int size)&#x2F;&#x2F;按size指定的大小创建缓冲区</li>
</ul>
<h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><p>构造方法</p>
<ul>
<li>BufferedReader(Reader in):定义一个BufferedReader类修饰参数in指定的字符输入流</li>
<li>BufferedReader(Reader in,int size):定义一个BufferedReader类修饰参数in指定的字符输入流,参数size则用于指定缓冲区的大小，单位为字符</li>
</ul>
<p>常用方法</p>
<p>read():读取单个字符</p>
<p>readLine():读取一个文本行，并将其返回为一个字符串</p>
<h3 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h3><p>构造方法</p>
<ul>
<li>BufferedWriter(Writer out):创建一个BufferedWriter类修饰参数out指定的字符输出流</li>
<li>BufferedWriter(Writer out,int size):创建一个BufferedWriter类修饰参数out指定的字符输出流，参数size则用于缓冲区的大小，单位为字符</li>
</ul>
<p>常用方法</p>
<p>writer(String s,int off,int len)：写入字符串的某一部分</p>
<p>fiush():	刷新该流的缓存</p>
<p>newLine():写入一个行分隔符</p>
<h2 id="基本数据类型输入-输出流"><a href="#基本数据类型输入-输出流" class="headerlink" title="基本数据类型输入&#x2F;输出流"></a>基本数据类型输入&#x2F;输出流</h2><h3 id="DataInputStream"><a href="#DataInputStream" class="headerlink" title="DataInputStream"></a>DataInputStream</h3><p>构造方法：</p>
<p>DateInputStream(InputStream in);&#x2F;&#x2F;使用指定的底层InputStream类创建一个DataInputStream</p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>int read(byte[] b)</td>
<td>从包含的输入流中读取一定数量的字节，并将他们存储到缓存去数组b中</td>
</tr>
<tr>
<td>int read(byte[] b,int off,int len)</td>
<td>从包含的输入流中将最多len个字节,读入一个byte数组中</td>
</tr>
<tr>
<td>boolean readBoolean()</td>
<td>读取一个输入字节,如果该字节不是0，则返回true;如果是0，返回false</td>
</tr>
<tr>
<td>byte readByte()</td>
<td>读取并返回一个输入字节</td>
</tr>
<tr>
<td>char readChar()</td>
<td>读取2个输入字节并返回一个char型值</td>
</tr>
<tr>
<td>double readDouble()</td>
<td>读取8个输入字节,并返回一个double型值</td>
</tr>
<tr>
<td>float readFloat()</td>
<td>读取4个输入字节，并返回一个float型值</td>
</tr>
<tr>
<td>void readFully(byte[] b)</td>
<td>从输入流中读取一些字节，并将她们存储到缓冲区数组b中</td>
</tr>
<tr>
<td>void readFully(byte [] b,int off,int len)</td>
<td>从输入流中读取len个字节</td>
</tr>
<tr>
<td>int readInt()</td>
<td>读取4个输入字节并返回一个int型值</td>
</tr>
<tr>
<td>long readLong()</td>
<td>读取8个输入字节并返回一个long型值</td>
</tr>
<tr>
<td>short readShort()</td>
<td>读取2个输入字节并返回一个short型值</td>
</tr>
<tr>
<td>String readUTF()</td>
<td>从数据输入流中读取用UTF-8格式编码的Unicode字符格式的字符串</td>
</tr>
</tbody></table>
<h3 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h3><p>void构造方法</p>
<p>DatOutputStream(OutputStream out);&#x2F;&#x2F;创建一个新的数据输出流，将数据写入指定基础输出流</p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>void flush()</td>
<td>清空此数据输出流</td>
</tr>
<tr>
<td>int size()</td>
<td>返回计数器written,即到目前为止写入此数据输出流的字节数</td>
</tr>
<tr>
<td>void write(byte[] b,int off,int len)</td>
<td>将指定byte数组中从偏移量off开始的len个字节写入基础输出流</td>
</tr>
<tr>
<td>void write(int b)</td>
<td>将指定字节(参数b的8个低位)写入基础输出流</td>
</tr>
<tr>
<td>void writeBoolean(boolean v)</td>
<td>将一个boolean型值以一个字节形式写入基础输出流</td>
</tr>
<tr>
<td>void writeByte(int v)</td>
<td>将一个byte型值以一个字节形式写入基础输出流</td>
</tr>
<tr>
<td>void writeByte(String s)</td>
<td>将字符串按字节顺序写入基础输出流</td>
</tr>
<tr>
<td>void writeChar(int v)</td>
<td>将一个char型值以两个字节形式写入基础输出流，先写入高字节</td>
</tr>
<tr>
<td>void writeChats(String s)</td>
<td>将字符串按字符顺序写入基础输出流</td>
</tr>
<tr>
<td>void writeDouble(double v)</td>
<td>使用Double类中的doubleToLongBits()方法将double参数转换成一个long型值，然后将该long的值以8个字节形式写入寄出输出流</td>
</tr>
<tr>
<td>void writeFloat(float v)</td>
<td>使用Float类中的floatToIntBits()方法将float参数装换成一个int型值，然后将该int型值以4个字节形式写入基础输出流，先写入高字节</td>
</tr>
<tr>
<td>void writeInt(int v)</td>
<td>将一个int型值以4个字节形式写入基础输出流，先写入高字节</td>
</tr>
<tr>
<td>void writeLong(long v)</td>
<td>将一个long型的值以8个字节形式写入基础输出流，先写入高字节</td>
</tr>
<tr>
<td>void writeShort(int v)</td>
<td>将一个short型值以2个字节形式写入基础输出流，先写入高字节</td>
</tr>
<tr>
<td>void writerUTF(String str)</td>
<td>以与及其无关的方式使用UTF-8修改版编码，将一个字符串写入基础输出流</td>
</tr>
</tbody></table>
<h2 id="zip压缩输入-输出流"><a href="#zip压缩输入-输出流" class="headerlink" title="zip压缩输入&#x2F;输出流"></a>zip压缩输入&#x2F;输出流</h2><h3 id="zipOutputStream"><a href="#zipOutputStream" class="headerlink" title="zipOutputStream"></a>zipOutputStream</h3><p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>void putNextEntry(ZipEntry entry)</td>
<td>开始写一个型的ZIPEntry对象，并将流内的文职移至此entry所指数据的开头</td>
</tr>
<tr>
<td>void write(byte[] index off,int len)</td>
<td>将字节数组写入当前zip条目的数据</td>
</tr>
<tr>
<td>void finish()</td>
<td>完成写入zip输出流的内容，无须关闭他配合的OutputStream类</td>
</tr>
<tr>
<td>void setComment(String comment)</td>
<td>设置此ZIP压缩文件的注释文字</td>
</tr>
</tbody></table>
<p>将文件写入压缩文件的一般步骤如下：</p>
<ol>
<li>生成和所要是生成的呀搜文件相关联的压缩类对象</li>
<li>生成和所要生成的压缩文件通常不止包含一个文件，将每个要加入的文件称为一个压缩入口，使用ZIPEntry(String FileName)生成压缩入口对象</li>
<li>使用putNextEntry(ZipEntry entry)将压缩入口加入压缩文件</li>
<li>将文件内容写入此压缩文件</li>
<li>使用CloseEntry()结束目前的压缩入口，继续下一个压缩入口</li>
</ol>
<h2 id="ZipInputStream"><a href="#ZipInputStream" class="headerlink" title="ZipInputStream"></a>ZipInputStream</h2><p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>int read(byte[] ,int off,int len)</td>
<td>读取数组b中从off偏移量开始的长度为len的字节</td>
</tr>
<tr>
<td>int available()</td>
<td>判断是否已经读完目前entry指定的数据；已读完返回0，否则返回1</td>
</tr>
<tr>
<td>void closeEntry()</td>
<td>关闭当前Zip条目并定流已读取下一个的条目</td>
</tr>
<tr>
<td>long skip(long n)</td>
<td>跳过当前Zip条目中指定字节数</td>
</tr>
<tr>
<td>ZipEntry getNextEntry()</td>
<td>读取下一个ZipEntry对象，并将流内的位置移至该entry所指数据的开头</td>
</tr>
<tr>
<td>ZipEntry createZipEntry(String name)</td>
<td>以指定的name参数新建一个ZipEntry对象</td>
</tr>
</tbody></table>
<p>应用ZIpInputStream类将文件从压缩文件找那个读出的一般步骤如下</p>
<ol>
<li>生成和所要读入的压缩文件相关联的压缩类对象</li>
<li>利用getNextEntry()方法得到下一个压缩入口</li>
</ol>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><h2 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h2><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public String getName()</strong> 返回由此抽象路径名表示的文件或目录的名称。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">**public String getParent()**返回此抽象路径名的父路径名的路径名字符串，如果此路径名没有指定父目录，则返回 <code>null</code>。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public File getParentFile()</strong> 返回此抽象路径名的父路径名的抽象路径名，如果此路径名没有指定父目录，则返回 <code>null</code>。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public String getPath()</strong> 将此抽象路径名转换为一个路径名字符串。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>public boolean isAbsolute()</strong> 测试此抽象路径名是否为绝对路径名。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>public String getAbsolutePath()</strong> 返回抽象路径名的绝对路径名字符串。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>public boolean canRead()</strong> 测试应用程序是否可以读取此抽象路径名表示的文件。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>public boolean canWrite()</strong> 测试应用程序是否可以修改此抽象路径名表示的文件。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>public boolean exists()</strong> 测试此抽象路径名表示的文件或目录是否存在。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>public boolean isDirectory()</strong> 测试此抽象路径名表示的文件是否是一个目录。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>public boolean isFile()</strong> 测试此抽象路径名表示的文件是否是一个标准文件。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>public long lastModified()</strong> 返回此抽象路径名表示的文件最后一次被修改的时间。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>public long length()</strong> 返回由此抽象路径名表示的文件的长度。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>public boolean createNewFile() throws IOException</strong> 当且仅当不存在具有此抽象路径名指定的名称的文件时，原子地创建由此抽象路径名指定的一个新的空文件。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><strong>public boolean delete()</strong>  删除此抽象路径名表示的文件或目录。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><strong>public void deleteOnExit()</strong> 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><strong>public String[] list()</strong> 返回由此抽象路径名所表示的目录中的文件和目录的名称所组成字符串数组。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><strong>public String[] list(FilenameFilter filter)</strong> 返回由包含在目录中的文件和目录的名称所组成的字符串数组，这一目录是通过满足指定过滤器的抽象路径名来表示的。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><strong>public File[] listFiles()</strong>  返回一个抽象路径名数组，这些路径名表示此抽象路径名所表示目录中的文件。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><strong>public File[] listFiles(FileFilter filter)</strong> 返回表示此抽象路径名所表示目录中的文件和目录的抽象路径名数组，这些路径名满足特定过滤器。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><strong>public boolean mkdir()</strong> 创建此抽象路径名指定的目录。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><strong>public boolean mkdirs()</strong> 创建此抽象路径名指定的目录，包括创建必需但不存在的父目录。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><strong>public boolean renameTo(File dest)</strong>  重新命名此抽象路径名表示的文件。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><strong>public boolean setLastModified(long time)</strong> 设置由此抽象路径名所指定的文件或目录的最后一次修改时间。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><strong>public boolean setReadOnly()</strong> 标记此抽象路径名指定的文件或目录，以便只可对其进行读操作。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><strong>public static File createTempFile(String prefix, String suffix, File directory) throws IOException</strong> 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><strong>public static File createTempFile(String prefix, String suffix) throws IOException</strong> 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><strong>public int compareTo(File pathname)</strong> 按字母顺序比较两个抽象路径名。</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left"><strong>public int compareTo(Object o)</strong> 按字母顺序比较抽象路径名与给定对象。</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left"><strong>public boolean equals(Object obj)</strong> 测试此抽象路径名与给定对象是否相等。</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left"><strong>public String toString()</strong>  返回此抽象路径名的路径名字符串。</td>
</tr>
</tbody></table>
<h2 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h2><p>File(String path)：如果path是实际存在的路劲，则该File对象表示的目录，如果path是文件名，则该File对象表示的是文件</p>
<p>File(String path,String name):path是路径名，name是文件名</p>
<p>File(File dir,String name):dir是路径对象，name是文件名</p>
<h2 id="File类中的常用常量"><a href="#File类中的常用常量" class="headerlink" title="File类中的常用常量"></a>File类中的常用常量</h2><p>public static final String pathSeparator:用来分隔连续多个路径字符串,在Windows操作系统中是指“;”，示例：Java -cp test.jar;abc.jar Hello World</p>
<p>public static final String separtor(不用大写):用来分隔同一个路径字符串中的目录，在window操作系统中是指“&#x2F;”,示例：C:&#x2F;Program Files&#x2F;Common Files</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>定义：在编程的角度来看，递归指的是方法定义中调用方法本身的现象</p>
<p>递归解决问题的思路</p>
<p>把一个复杂的问题层层转化为与一个原问题相似的规模较小的题目来求解，递归只需要少量的程序就可描述出解题过程所需要的多次重复计算</p>
<p>递归的注意事项</p>
<ol>
<li>要设置递归出口：否则会出现内存溢出</li>
<li>递归规则：与原问题相似的规模较小的问题</li>
</ol>
<h2 id="使用File类注意事项"><a href="#使用File类注意事项" class="headerlink" title="使用File类注意事项"></a>使用File类注意事项</h2><ul>
<li>在删除目录时，需要先删除目录的所有文件，才能进行删除目录</li>
<li>File对象里面接得是路径名，与路径的真实内容无关</li>
</ul>
<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><h2 id="jdbc连接数据库"><a href="#jdbc连接数据库" class="headerlink" title="jdbc连接数据库"></a>jdbc连接数据库</h2><ol>
<li>用Class.forname()注册驱动(一般只需被加载一次，一般放在static静态代码构造块)</li>
<li>创建连接并进行封装<ol>
<li>设置mysql连接url地址:(格式：)jdbc:mysql:&#x2F;&#x2F;主机名:端口号&#x2F;数据库名”,”用户名”,”登录密码</li>
<li>使用DriverManager.getConnection(url, user, password);方法进行连接</li>
</ol>
</li>
<li>关闭连接的<ol>
<li>判断连接、数据声明、结果集是否为null</li>
<li>通过各自close()方法关闭连接</li>
</ol>
</li>
</ol>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bdqn.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: duan.rong.gui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022/3/31 11:21:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 主方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * 类描述：jdbc连接数据类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Util</span> &#123;</span><br><span class="line">    <span class="comment">/*声明属性*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> 段荣贵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> //TODO 肖萧奈何桥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 9:40:41 2022/4/8</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * 方法描述：</span></span><br><span class="line"><span class="comment">     * 注册驱动，驱动只需要加载一次</span></span><br><span class="line"><span class="comment">     * 即可所以写在静态代码段中</span></span><br><span class="line"><span class="comment">     * （static）类的静态代码块，随着类的加载，只执行一次。</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*加载驱动*/</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法描述：</span></span><br><span class="line"><span class="comment">     * 建立链接。需要单独创建一个方法</span></span><br><span class="line"><span class="comment">     * 通过返回值返回链接对象</span></span><br><span class="line"><span class="comment">     * 链接每次用完之后就会关闭</span></span><br><span class="line"><span class="comment">     * mysql连接url地址:jdbc:mysql://主机名:端口号/数据库名&quot;,&quot;用户名&quot;,&quot;登录密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> 段荣贵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> //TODO 肖萧奈何桥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 19:55:23 2022/4/7</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;drg1224605&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*如果连接成功，那么就返回null*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql,args 语句，对象数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> 段荣贵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> //TODO 肖萧奈何桥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 19:55:16 2022/4/7</span></span><br><span class="line"><span class="comment">     * 方法描述：增删改的通用方法</span></span><br><span class="line"><span class="comment">     * Object ... 可变参数，多半用于重写</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">executeUpdate</span><span class="params">(String sql, Object... args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = getConnection().prepareStatement(sql);</span><br><span class="line">            <span class="comment">/*遍历args的长度*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*执行更新语句*/</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/*关闭连接，释放资源*/</span></span><br><span class="line">            close(conn, ps, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql,args 语句,对象数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法描述：用于普通遍历查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> 段荣贵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> //TODO 肖萧奈何桥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 20:13:36 2022/4/7</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">executeQuery</span><span class="params">(String sql, Object... args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*实例化对象，创建连接*/</span></span><br><span class="line">            conn = getConnection();</span><br><span class="line">            <span class="comment">/*准备好的声明*/</span></span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            <span class="comment">/*遍历args的长度,获取数据*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*执行查询*/</span></span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="comment">/*存放数据到List中*/</span></span><br><span class="line">            List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">/*查询本次查询结果集有多少列*/</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rs.getMetaData().getColumnCount();</span><br><span class="line">            <span class="comment">/*通过while循环存放数据*/</span></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">/*一行数据用一个Map接收*/</span></span><br><span class="line">                Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                <span class="comment">/*通过for循环进行*/</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    <span class="comment">/*获取每个列的名称*/</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getMetaData().getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">/*通过列名来获取这个列的值*/</span></span><br><span class="line">                    map.put(name, rs.getObject(name));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*将每一个的数据添加存放到List中*/</span></span><br><span class="line">                list.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            close(conn, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法描述：消除链接，释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> 段荣贵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> //TODO 肖萧奈何桥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 20:14:23 2022/4/7</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn, PreparedStatement st, ResultSet rs)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*判断连接是否为null*/</span></span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="literal">null</span>) &#123;</span><br><span class="line">                st.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Dirver接口"><a href="#Dirver接口" class="headerlink" title="Dirver接口"></a>Dirver接口</h2><p>作用：</p>
<p>用于加载和注册驱动</p>
<p>连接驱动的语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;驱动地址&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><p>作用：</p>
<p>用户与驱动程序之间，跟踪可用的驱动程序，在数据库和驱动程序之间建立连接，另外也处理诸如驱动程序登录事件限制及登录和跟踪消息的显示等事务</p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>Modifier and Type</th>
<th>Method and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>static void</code></td>
<td><code>deregisterDriver(Driver driver)</code>  从 <code>DriverManager</code>的注册驱动程序列表中删除指定的驱动程序。</td>
</tr>
<tr>
<td><code>static Connection</code></td>
<td><code>getConnection(String url)</code>  尝试建立与给定数据库URL的连接。</td>
</tr>
<tr>
<td><code>static Connection</code></td>
<td><code>getConnection(String url, Properties info)</code>  尝试建立与给定数据库URL的连接。</td>
</tr>
<tr>
<td><code>static Connection</code></td>
<td><code>getConnection(String url, String user,  String password)</code>  尝试建立与给定数据库URL的连接。</td>
</tr>
<tr>
<td><code>static Driver</code></td>
<td><code>getDriver(String url)</code>  尝试查找了解给定URL的驱动程序。</td>
</tr>
<tr>
<td><code>static Enumeration</code></td>
<td><code>getDrivers()</code>  使用当前调用者可以访问的所有当前加载的JDBC驱动程序检索枚举。</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>getLoginTimeout()</code>  获取尝试登录数据库时驱动程序可以等待的最长时间（秒）。</td>
</tr>
<tr>
<td><code>static PrintStream</code></td>
<td><code>getLogStream()</code>  已弃用  使用<code>getLogWriter</code></td>
</tr>
<tr>
<td><code>static PrintWriter</code></td>
<td><code>getLogWriter()</code>  检索日志记录器。</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>println(String message)</code>  打印到当前JDBC日志流的消息。</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>registerDriver(Driver driver)</code>  注册与给定的驱动程序 <code>DriverManager</code> 。</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>registerDriver(Driver driver, DriverAction da)</code>  注册与给定的驱动程序 <code>DriverManager</code> 。</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>setLoginTimeout(int seconds)</code>  设置驱动程序在识别驱动程序后尝试连接到数据库时等待的最长时间（秒）。</td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>setLogStream(PrintStream out)</code>  已弃用  使用<code>setLogWriter</code></td>
</tr>
<tr>
<td><code>static void</code></td>
<td><code>setLogWriter(PrintWriter out)</code>  设置 <code>DriverManager</code>和所有驱动程序使用的记录&#x2F;跟踪  <code>PrintWriter</code>对象。</td>
</tr>
</tbody></table>
<h2 id="Conneciton"><a href="#Conneciton" class="headerlink" title="Conneciton"></a>Conneciton</h2><p>定义:代表与数据库的连接</p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>cleaWarining()</td>
<td>清除当前的连接警告</td>
</tr>
<tr>
<td>close()</td>
<td>关闭数据库连接</td>
</tr>
<tr>
<td>createStratement()</td>
<td>建立一个用于执行sql语句的Statement对象</td>
</tr>
<tr>
<td>isClosed()</td>
<td>返回该数据库连接是否关闭</td>
</tr>
<tr>
<td>isReadOnly()</td>
<td>判断当前连接是不是只读的</td>
</tr>
<tr>
<td>nativeSQL（String sql)</td>
<td>jdbc驱动器向数据库提交Sql语句时，返回该语句</td>
</tr>
<tr>
<td>PrepareCall(String sql)</td>
<td>返回用于调用存储过程的CallableStatement对象</td>
</tr>
<tr>
<td>prepareStatement(String sql)</td>
<td>返回执行动态SQL 语句的preparedStatement对象</td>
</tr>
</tbody></table>
<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>close()</td>
<td>关闭当前Statement对象</td>
</tr>
<tr>
<td>execute(String sql)</td>
<td>执行Statement对象</td>
</tr>
<tr>
<td>executeQuery(String SQL)</td>
<td>执行查询语句</td>
</tr>
<tr>
<td>executeUpdate(String sql)</td>
<td>执行更新语句</td>
</tr>
<tr>
<td>getMaxFieIdSize()</td>
<td>返回结果集中某字段的当期那最大长度</td>
</tr>
<tr>
<td>getMaxRows()</td>
<td>返回结构集中当前的最大行数</td>
</tr>
<tr>
<td>getMoreResults()</td>
<td>移到Statement对象的下一个结果出，用于返回多结构集的Sql语句</td>
</tr>
<tr>
<td>getResultSet()</td>
<td>返回当前结果集</td>
</tr>
<tr>
<td>getUpdateCount()</td>
<td>返回多个结果语句中的当前结果</td>
</tr>
<tr>
<td>getQueryTimeOut()</td>
<td>返回jdbc驱动器等待Statement的对象执行语句的延迟时间(秒)</td>
</tr>
<tr>
<td>setMaxFieIdSize(int maxFieIdSize)</td>
<td>设置结果集中返回的最大字段长度</td>
</tr>
<tr>
<td>setMaxRows(int maxRows)</td>
<td>设置结果集中包含的最大行数</td>
</tr>
<tr>
<td>setQueryTimeOut(int seconds)</td>
<td>设置jdbc驱动器等待Statement对象执行语句的延迟时间(秒)</td>
</tr>
</tbody></table>
<h2 id="PrepatedStatement"><a href="#PrepatedStatement" class="headerlink" title="PrepatedStatement"></a>PrepatedStatement</h2><p>定义：用来执行动态的SQL语句，表示预编译的Sql语句的对象。然后可以使用该对象多次有效的执行此语句，在SQl语句中可以具有同一个或多个参数，参数的值在SQL语句创建时未指定，而是使用”?(占位符)代替”，在SQL语句执行钱，再使用方法赋值</p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>clearParameters()</td>
<td>清除当前SQl语句包含所有参数</td>
</tr>
<tr>
<td>execute()</td>
<td>执行SQL语句或存储过程</td>
</tr>
<tr>
<td>executeQuery()</td>
<td>执行查询语句</td>
</tr>
<tr>
<td>executeUpdate()</td>
<td>执行更新语句</td>
</tr>
<tr>
<td>setByte(int index,byte x)</td>
<td>将指定的参数设置为byte型值</td>
</tr>
<tr>
<td>setDate(int index,Date x)</td>
<td>将指定的参数设置为Date型值</td>
</tr>
<tr>
<td>setDouble(int index,double x)</td>
<td>将指定的参数设置为double型值</td>
</tr>
<tr>
<td>setFloat(int index,float x)</td>
<td>将指定的参数设置为float型值</td>
</tr>
<tr>
<td>setInt(int index,int x)</td>
<td>将指定的参数设置为int型值</td>
</tr>
<tr>
<td>setLong(int index,long x)</td>
<td>将指定的参数设置为Long型值</td>
</tr>
<tr>
<td>setNull(int index,sqlType x)</td>
<td>将指定的参数设置为Null型值</td>
</tr>
<tr>
<td>setString(int index,String x)</td>
<td>将指定的参数设置为String型值</td>
</tr>
<tr>
<td>setTime(int index,Time x)</td>
<td>将指定的参数设置为Time型值</td>
</tr>
</tbody></table>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>setDate()方法设置的日期内容的类型是Java.sql.Date类型，而不是Java.util.Date类型</p>
<h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><p>定义：几乎所有数据操作的方法和查询都将数据作为ResultSet对象返回，此对象可以包含任意数量的命名列，可以按照名称或索引访问这些列，而且还可以包含一行或多行，可以按照顺序自上而下注意访问</p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>cliose()</td>
<td>关闭当前的ResultSet对象</td>
</tr>
<tr>
<td>findColumn()</td>
<td>查找指定的列名，并返回该列的索引</td>
</tr>
<tr>
<td>getBoolean(int index)</td>
<td>将指定索引的列数据作为boolean型值返回</td>
</tr>
<tr>
<td>getByte(int index)</td>
<td>将指定索引的列数据作为byte型值返回</td>
</tr>
<tr>
<td>getDouble(int index)</td>
<td>将指定索引的列数据作为Double值返回</td>
</tr>
<tr>
<td>getFloat(int index)</td>
<td>将指定索引的列数据作为float型值返回</td>
</tr>
<tr>
<td>getInt(int index)</td>
<td>将指定索引的列数据作为int型值返回</td>
</tr>
<tr>
<td>getLong(int index)</td>
<td>将指定索引的列数据作为long型值返回</td>
</tr>
<tr>
<td>getString(int index)</td>
<td>将指定索引的列数据作为String型值返回</td>
</tr>
<tr>
<td>getTime(int index)</td>
<td>将指定索引的列数据作为Time型值返回</td>
</tr>
<tr>
<td>getBoolean(String columnName)</td>
<td>将指定列的名称的列数据作为boolean型值返回</td>
</tr>
<tr>
<td>getByte(String columnName)</td>
<td>将指定列的名称的列数据作为byte型值返回</td>
</tr>
<tr>
<td>getDate(String columnName)</td>
<td>将指定列的名称的列数据作为Date型值返回</td>
</tr>
<tr>
<td>getDouble(String columnName)</td>
<td>将指定列的名称的列数据作为double型值返回</td>
</tr>
<tr>
<td>getFloat(String columnName)</td>
<td>将指定列的名称的列数据作为float型值返回</td>
</tr>
<tr>
<td>getInt(String columnName)</td>
<td>将指定列的名称的列数据作为int型值返回</td>
</tr>
<tr>
<td>getLong(String columnName)</td>
<td>将指定列的名称的列数据作为long型值返回</td>
</tr>
<tr>
<td>getString(String columnName)</td>
<td>将指定列的名称的列数据作为String型值返回</td>
</tr>
<tr>
<td>getTime(String columnName)</td>
<td>将指定列的名称的列数据作为Time型值返回</td>
</tr>
<tr>
<td>next()</td>
<td>将结果集指针下移一条</td>
</tr>
</tbody></table>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>程序是指使用计算机语言编写的静态代码，他是应用软件执行的基础</p>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>软件是指计算机系统中控制硬件完成，表达系统内信息组织方法的数据结构，以及有关于软件开发，测试，维护，使用的所有文档的总和（软件&#x3D;程序+数据结构+文档）</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统结构的基础，是一个正在执行的程序，是计算机中正在运行的程序实例，可以分配给处理器并由处理器执行的一个实体，由单一顺序的执行显示，一个当前状态和一组相关的系统资源描述的活动单元，多进程是指操作系统按照时间片轮转方式同时运行多个程序的情况</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是程序中一个单一的顺序控制流程，是程序执行流的最小单元，另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，</p>
<p>线程自己不拥有资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程工商进程拥有的全部资源，一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行，由于线程之间的相互制约，致使线程在运行中呈现间断性，线程也有就绪、阻塞和运行三个基本状态，每一个程序都至少有一个线程，若程序只有一个线程，就是程序本身</p>
<p>​	在单个程序中同时运行多个线程完成不同的工作，称为多线程，多线程是指操作系统每次分时给程序一个时间片的CPU时间内，在若干个独立的可控制线程之间进行切换，线程间可以共享相同的内存空间，并利用这些共享内存进行数据交换，实时通信以及同步操作等。</p>
<h2 id="Java里面的多线程"><a href="#Java里面的多线程" class="headerlink" title="Java里面的多线程"></a>Java里面的多线程</h2><h3 id="线程类-Thread"><a href="#线程类-Thread" class="headerlink" title="线程类(Thread)"></a>线程类(Thread)</h3><ol>
<li><p>构造方法</p>
<ul>
<li>public Thread():创建一个线程</li>
<li>public Thread(String name):创建命名为name的线程</li>
<li>public Thread(Runnable target,String name):创建基于含有线程体对象的命名线程</li>
<li>public Thread(ThreadGroup group,Runnable target):创建基于含有线程题对象的命名线程，并指定线程组</li>
</ul>
</li>
<li><p>run()方法</p>
<p>每个线程都通过某个特定对象的run()方法完成其操作，run()方法称为线程题</p>
</li>
<li><p>改变线程状态的方法：如start()、sleep()、stop()、suspend()、resume()、yield()和wait()方法</p>
</li>
<li><p>对线程属性进行操作的方法：如setPriority(),setName(),getPriority(),getId()，getName(),getState()和isAlive()等方法</p>
</li>
</ol>
<h3 id="线程组-ThreadGroup"><a href="#线程组-ThreadGroup" class="headerlink" title="线程组(ThreadGroup)"></a>线程组(ThreadGroup)</h3><p>定义：ThreadGroup类管理一组线程，一个线程组也可以属于另外一个线程组，当主线程被创建时，同时也创建了一个主线程组，在主线程中创建的线程也属于主线程组，利用线程组也可以同时改变大量线程的状态</p>
<ol>
<li>构造方法<ul>
<li>ThreadGroup(String name):创建指定名字为name的线程组</li>
<li>ThreadGroup(ThreadGroup parent,String name):创建指定名称为name，父线程组为patent的线程组</li>
</ul>
</li>
<li>其他常用成员方法<ul>
<li>int activeGroupCount()：获得线程组中的线程数量</li>
<li>void suspend()：挂起线程组</li>
<li>void resune():恢复线程组</li>
<li>void stop():停止线程组</li>
</ul>
</li>
</ol>
<h2 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h2><h3 id="继承Thread类创建多线程"><a href="#继承Thread类创建多线程" class="headerlink" title="继承Thread类创建多线程"></a>继承Thread类创建多线程</h3><p>继承Thread类是需要重写其中的run()方法，优点：是可以在子类中增加新成员，但是Java不支持多重继承，创建的线程子类不能在扩展其他的类</p>
<h3 id="实现Runnable接口创建多线程"><a href="#实现Runnable接口创建多线程" class="headerlink" title="实现Runnable接口创建多线程"></a>实现Runnable接口创建多线程</h3><p>定义：创建一个类以实现接口Runnable，作为线程的目标对象，在初始化一个线程类时，将目标对象传递给Thread实例，由该目标对象提供run()方法，优点是任何实现接口Runnable的对象都可以作为一个线程的目标对象，类的Thread本身也实现了接口Runable，</p>
<h3 id="两种实现方法的对比"><a href="#两种实现方法的对比" class="headerlink" title="两种实现方法的对比"></a>两种实现方法的对比</h3><ol>
<li>继承Thread类<ul>
<li>不能在继承其他类，可以直接操作线程</li>
<li>编写简单，无需使用Thread.currentThread()方法</li>
</ul>
</li>
<li>实现Runbnable接口<ul>
<li>可以将CPU、代码、数据分开，形成清晰的线程模型</li>
<li>此时是可以继承其他类的</li>
<li>保持程序风格的一致性，体现面向对象思想的体现</li>
<li>避免了Java单继承的局限性</li>
</ul>
</li>
</ol>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><h3 id="线程基本状态转换图"><a href="#线程基本状态转换图" class="headerlink" title="线程基本状态转换图"></a>线程基本状态转换图</h3><p> <img src="https://pics7.baidu.com/feed/a1ec08fa513d26971af281a4d2e81ef34216d8c6.png?token=e1ca67d3857fec203d7c333e1f71a7d8" alt="img"> </p>
<p> <img src="https://pics5.baidu.com/feed/e4dde71190ef76c69aaddb88100551f2af516735.png?token=3954f1ddd8892390874029a802afd289" alt="img"> </p>
<h3 id="新建状态"><a href="#新建状态" class="headerlink" title="新建状态"></a>新建状态</h3><p> 用new语句创建的线程对象处于新建状态，此时它和其他Java对象一样，仅仅在堆区中被分配了内存。 </p>
<h3 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h3><p> 当一个线程对象创建后，其他线程调用它的start()方法，该线程就进入就绪状态，Java虚拟机会为它创建方法调用栈和程序计数器。处于这个状态的线程位于可运行池中，不一定立即执行，由CPU调用。 </p>
<h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><p> 处于这个状态的线程占用CPU，执行程序代码。在并发运行环境中，如果计算机只有一个CPU，那么任何时刻只会有一个线程处于这个状态。如果计算机有多个CPU，那么同一时刻可以让几个线程占用不同的CPU，使它们都处于运行状态。 </p>
<h3 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h3><p>指线程因为某些原因放弃CPU，暂时停止运行。当线程处于阻塞状态时，Java虚拟机不会给线程分配CPU，直到线程重新进入就绪状态，它才有机会转到运行状态。 </p>
<p>有四种情况</p>
<ul>
<li>调用了sleep(int sleeptime):线程会让出CPU使用权sleeptime毫秒</li>
<li>调用了wait()方法,等待一个条件变量</li>
<li>调用了suspend()方法</li>
<li>执行某个操作进入阻塞状态</li>
<li>调用join()方法将正在运行的线程暂时停止，等待其他线程执行完毕一起结束</li>
</ul>
<p>如果一个线程处于阻塞状态没那么这个线程暂时无法进入就绪队列，处于阻塞状态的线程通常需要有某些事件才能唤醒，至于有什么事件唤醒该线程，这取决与阻塞的原因，针对于上面的四种情况，都有其对应方法</p>
<ul>
<li>若调用了sleep(int sleepTime)方法后：线程处于阻塞状态，该方法的参数sleeptime为睡眠时间，单位为毫秒，当这个时间过去后，线程进入就绪状态</li>
<li>若线程在等待一个条件变量，要想停止等待，则需要该条件变量所在的对象调用notify()或notifyAll()方法通知线程进入就绪队列等待CPU资源</li>
<li>若线程调用了suspend()方法，则由其他线程调用resume()方法恢复该线程，并进入就绪队列等待执行</li>
<li>进入阻塞状态是线程不能进入就绪队列，只能等待引起阻塞的原因消除后，线程才能进入就绪队列等待调度，若由于输入&#x2F;输出发生线程阻塞，则规定的I&#x2F;O指令完成即可恢复线程进入就绪状态</li>
<li>等待调用Join()方法的线程执行完毕</li>
</ul>
<h3 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a>终止状态</h3><p>​	终止状态又称为死亡状态或停止状态，处于这种状态的线程已经不能再继续执行，其中的原因可能是线程已经执行完毕，正常的撤销，即执行完run()方法中的全部语句；也可能是被强行终止，例如：通过执行stop()或destroy()方法终止线程</p>
<h2 id="线程的调度与优先级"><a href="#线程的调度与优先级" class="headerlink" title="线程的调度与优先级"></a>线程的调度与优先级</h2><h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3><p>程序中的多个线程并发执行，若某个线程想被执行，则必须得到CPU的使用权，Java虚拟机按照特定的机制为程序中的每个线程分配CPU的使用权，称为线程的调度，</p>
<p>线程的调度有两种模型，分别是分时调度模型和抢占式调度模型，</p>
<p>分时调度是指让所有的线程轮流获得CPU的使用权，并且平均分配每个线程占用的CPU时间片，</p>
<p>抢占式调度模型是指让就绪队列中优先级高的线程优先占有CPU，而对于优先级相同的线程，随机选择一个线程使其占用CPU，当它失去CPU的使用权，在随机选择其他线程获取CPU使用权，Java虚拟机默认采用抢占式调度模型，一般不需要考虑，但也有某些特定需求，这时需要有程序员控制CPU的调度模型</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><h3 id="什么是线程优先级"><a href="#什么是线程优先级" class="headerlink" title="什么是线程优先级"></a>什么是线程优先级</h3><p>在多线程编程中，支持为每个线程设置优先级。优先级高的线程在排队执行时会获得更多的CPU执行时间，得到更快的响应。在实际程序中，可以根据逻辑的需要，将需要得到及时处理的线程设置成较高的优先级，而把对时间要求不高的线程设置成比较低的优先级</p>
<p>Java虚拟机有线程调度器负责管理线程调度器把线程分为10个级别，有整数值1~10表述，优先级越高，越早执行，优先级越低你，越晚执行，优先级相同是，则遵循队列的”先进先出”的原则</p>
<h3 id="优先级整数常量"><a href="#优先级整数常量" class="headerlink" title="优先级整数常量"></a>优先级整数常量</h3><ul>
<li>MIN_PRIORITY:线程能具有的最小优先级(1)</li>
<li>MAX_PRIORITY:线程能具有的最大优先级(10)</li>
<li>NORM_PRIORITY:线程的常用优先级(5)</li>
</ul>
<p>当线程创建时，优先级默认为NORM_PRIORITY标识的整数，Thread类与优先级相关的方法有setPriority(int grade)和getPriority(int grade)方法用来设置线程的优先级，整形参数作为线程的优先级，其范围必须在MIN_PRIORITY和MAX_PRIORITY之间，并且不大于线程的Thread对象所属线程组的优先级</p>
<p>设置和获取线程优先级的方法</p>
<ul>
<li>int getPriority():返回此线程的优先级</li>
<li>void setPriority(int newPriority):更改此线程的优先级</li>
</ul>
<h2 id="线程的控制"><a href="#线程的控制" class="headerlink" title="线程的控制"></a>线程的控制</h2><h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>执行可以用stop()方法，</p>
<p>注意事项</p>
<ul>
<li>stop()只是停止了线程的执行，并且这个线程不能用start()方法重新启动，</li>
<li>一般情况下，不用stop()方法，只是简单地让他执行完即可</li>
<li>很多复杂的多线程程序将需要控制每一个线程，在这种情况下会用到stop()方法</li>
</ul>
<h3 id="测试线程的状态"><a href="#测试线程的状态" class="headerlink" title="测试线程的状态"></a>测试线程的状态</h3><p>方法为isAlive()，一个线程已经启动而且没有停止就被认为是激活的，如果线程t是激活的，则t.isAlive()将返回true,但该线程是可运行的或是不可运行，不能做进一步的区分，如果返回false,则该线程是新创建或已被终止的</p>
<h3 id="线程的休眠"><a href="#线程的休眠" class="headerlink" title="线程的休眠"></a>线程的休眠</h3><p>通过静态sleep()方法可以指定线程睡眠一段时间后进入休眠等待状态，当前线程调用sleep(long millis)方法后，在指定时间内该线程不执行，是其他线程得到执行的机会，sleep(long millis)方法会抛出异常，因此在调用此方法时需要捕获异常。需要注意的是，sleep()方法只能控制当前正在运行的线程休眠，而不能控制其他线程休眠，当线程休眠时间结束后，线程会返回就绪状态，而不是立即开始运行</p>
<h3 id="线程的插队"><a href="#线程的插队" class="headerlink" title="线程的插队"></a>线程的插队</h3><p>使用join()方法使当前线程等待调用该方法的线程执行完毕后再继续</p>
<h3 id="线程的让步"><a href="#线程的让步" class="headerlink" title="线程的让步"></a>线程的让步</h3><p>可以通过yield()方法实现，与sleep()方法相似,都是让当前运行的线程暂停，区别在与yield()方法不会阻塞该线程，只是将线程转换为就绪状态，让系统在重新调度一次，只有与当前线程优先级相同或更高的线程才能获得执行的机会，</p>
<h2 id="多线程的互斥与同步"><a href="#多线程的互斥与同步" class="headerlink" title="多线程的互斥与同步"></a>多线程的互斥与同步</h2><h3 id="线程的死锁"><a href="#线程的死锁" class="headerlink" title="线程的死锁"></a>线程的死锁</h3><p>在进行多线程编程时，经常会出现多个线程共享数据或资源的问题，因此在多线程运行时，必须考虑每个线程的状态和行为，否则就不能保证程序的运行结果的正确性，多个线程共享的资源称为“临界资源”</p>
<p>当两个或以上的形成在执行过程中，争夺临界资源而造成一种互相等待的现象，若无外力作用，他们都将无法推进下去，永远处于相互等待中，此时称系统处于死锁状态，或系统产生了“死锁，”此时执行程序中两个或多个线程堵在等待被其他线程占用并阻塞了的资源，例如：一个线程视图从堆栈中读取数据(pop(方法))，而另一个线程视图向堆栈中写入数据(push())方法</p>
<h3 id="多线程的互斥"><a href="#多线程的互斥" class="headerlink" title="多线程的互斥"></a>多线程的互斥</h3><p>为保证线程共享资源操作的完整性，用关键字synchronized为共享资源加标记解决，</p>
<p>此标记是线程对共享资源互斥操作，此标记称为“互斥锁”，每个共享资源对象都有一个互斥锁，他保证任意时刻只能有一个线程访问共享资源，</p>
<p>例如：在堆栈操作中，程序读取数据时，将堆栈的互斥锁锁上，写入数据的线程就不能访问堆栈，当线程读取完毕，将锁打开后，写线程才有可能进行写操作，这样可以保证数据的一致性</p>
<p>使用形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line"><span class="comment">//限制部分代码段在执行时互斥</span></span><br><span class="line">  <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">    stackWrite(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> stackRead();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//限制方法在执行时互斥</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步方法的所对象是this</span></span><br><span class="line"><span class="comment">//同步静态方法：就是把synchronized添加到静态方法上</span></span><br><span class="line"><span class="comment">//同步静态方法的锁对象是类名.class</span></span><br></pre></td></tr></table></figure>

<h3 id="多线程的同步"><a href="#多线程的同步" class="headerlink" title="多线程的同步"></a>多线程的同步</h3><p>定义：控制共享资源的多线程的执行进度</p>
<p>Java通过wait()和notify()或notifyAll()方法实现线程之间的仙湖协调，</p>
<p>wait()方法可以使不能满足条件的线程释放互斥锁而进入就绪状态，</p>
<p>但其他线程释放资源时，会调用notify()方法唤醒就绪队列中的线程，使其资源恢复运行</p>
<h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>wait()、notify()和notifyAll()方法必须在已经持有锁的情况下执行，所以他们只能出现在synchronize作用的范围内</li>
<li>wait()方法用于释放已经持有的锁，进入就绪对象</li>
<li>notify()方法用于唤醒就绪队列中第一个线程并把他们移入锁申请队列</li>
<li>notifyAll()方法用于唤醒就绪队列中所有线程并把它们移入锁申请队列</li>
</ol>
<h4 id="同步的好处和弊端"><a href="#同步的好处和弊端" class="headerlink" title="同步的好处和弊端"></a>同步的好处和弊端</h4><ul>
<li>好处：解决了多线程的数据安全问题</li>
<li>弊端：当线程很多时，因为每一个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率</li>
</ul>
<h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>定义：Lock锁，可以得到和 synchronized一样的效果，即实现原子性、有序性和可见性</p>
<p>相较于synchronized，Lock锁可手动获取锁和释放锁、可中断的获取锁、超时获取锁</p>
<p>Lock 是一个接口，两个直接实现类：ReentrantLock（重入锁）, ReentrantReadWriteLock（读写锁）</p>
<p>概述</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> ...;</span><br><span class="line">l.lock(); <span class="comment">// 上锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// access the resource protected by this lock</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  l.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>定义：Java8新特性，他没有名称，但他有参数列表，函数主体、返回类型，可能还有一个可以抛出的异常列表</p>
<p>作用：简化代码，提高代码的复用率</p>
<p>注意事项</p>
<ol>
<li>在接口中使用lambda表达式时，只能在函数式接口中使用(只有一个抽象方法的接口)</li>
<li>lambda表达式只能有一行代码的情况下才能简化一行，如果有多行，那么就用代码块({})包裹</li>
<li>多个参数类型也可以去掉参数类型，但是必须加上括号，用逗号隔开每个参数</li>
</ol>
<p>基本语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">  <span class="comment">//一般</span></span><br><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bdqn.test4.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: duan.rong.gui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022/3/31 11:21:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 主方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * 类描述：</span></span><br><span class="line"><span class="comment"> * 推导lambda表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ILike like=<span class="keyword">new</span> <span class="title class_">Like</span>();</span><br><span class="line">        like.lambda();</span><br><span class="line">        <span class="comment">/*用lambda表达式来写函数式接口*/</span></span><br><span class="line">        like=()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i like lambda like&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p><img src="/Java.assets%5C1649749716858.png" alt="1649749716858"></p>
<h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h2><p>网络通信是指采用网络协议实现计算机之间的数据交换</p>
<p>网络协议是指通信的计算机双方约定好的规则集合</p>
<p> <img src="https://img-blog.csdnimg.cn/20210310111931783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTYyNg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> 、</p>
<h2 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h2><p><img src="/Java.assets%5C1649754586199.png" alt="1649754586199"></p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p><img src="/Java.assets%5C1649758504535.png" alt="1649758504535"></p>
<p><img src="/Java.assets%5C1649758859982.png" alt="1649758859982"></p>
<h2 id="端口和协议"><a href="#端口和协议" class="headerlink" title="端口和协议"></a>端口和协议</h2><p><img src="/Java.assets%5C1649760575993.png" alt="1649760575993"></p>
<p><img src="/Java.assets%5C1649760697434.png" alt="1649760697434"></p>
<p><img src="/Java.assets%5C1649760868386.png" alt="1649760868386"></p>
<h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>static InetAddress getByName(String host)</td>
<td>确定主机名称的IP地址。</td>
</tr>
<tr>
<td>static InetAddress getLocalHost()</td>
<td>返回本地主机的地址。</td>
</tr>
<tr>
<td>String getHostName()</td>
<td>获取此IP地址的主机名</td>
</tr>
<tr>
<td>String getHostAddress()</td>
<td>返回文本显示中的IP地址字符串。</td>
</tr>
<tr>
<td>boolean isReachable(NetworkInterface netif, int ttl,  int timeout)</td>
<td>测试该地址是否可达。</td>
</tr>
</tbody></table>
<h2 id="UDP通信程序"><a href="#UDP通信程序" class="headerlink" title="UDP通信程序"></a>UDP通信程序</h2><h3 id="UDP的通信原理"><a href="#UDP的通信原理" class="headerlink" title="UDP的通信原理"></a>UDP的通信原理</h3><p><img src="/Java.assets%5C1649761173653.png" alt="1649761173653"></p>
<h3 id="UPD发送数据"><a href="#UPD发送数据" class="headerlink" title="UPD发送数据"></a>UPD发送数据</h3><p><img src="/Java.assets%5C1649763110629.png" alt="1649763110629"></p>
<h3 id="UDP接收数据"><a href="#UDP接收数据" class="headerlink" title="UDP接收数据"></a>UDP接收数据</h3><p><img src="/Java.assets%5C1649763897805.png" alt="1649763897805"></p>
<p>三次握手</p>
<p><img src="/Java.assets%5C1649760834973.png" alt="1649760834973"></p>
<h2 id="TCP通信程序"><a href="#TCP通信程序" class="headerlink" title="TCP通信程序"></a>TCP通信程序</h2><h3 id="TCP通信原理"><a href="#TCP通信原理" class="headerlink" title="TCP通信原理"></a>TCP通信原理</h3><p><img src="/Java.assets%5C1649805802139.png" alt="1649805802139"></p>
<h3 id="TCP发送数据"><a href="#TCP发送数据" class="headerlink" title="TCP发送数据"></a>TCP发送数据</h3><p><img src="/Java.assets%5C1649808943497.png" alt="1649808943497"></p>
<h3 id="TCP接收数据"><a href="#TCP接收数据" class="headerlink" title="TCP接收数据"></a>TCP接收数据</h3><p><img src="/Java.assets%5C1649808902571.png" alt="1649808902571"></p>
<p>定义：</p>
<p>TCP定义了两台计算机之间进行可靠的传输而交换的数据和确认信息的格式，以及计算机为了确保数据的正确到达而采取的措施，协议规定了TCP软件怎样识别给定计算上的多个目的如何对分组重复这类差错进行恢复，协议还规定了两台计算机如何初始化一个TCP数据流传输以及如何结束这一传输，TCP最大的特点就是提供的是面向连接、<a href="">可靠的字节流服务</a></p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="反射机制的本质"><a href="#反射机制的本质" class="headerlink" title="反射机制的本质"></a>反射机制的本质</h2><p>在加载任何一个类是都会在方法去中建立，这个类特有的Class对象，Class对象包含了这个类的整个结构信息</p>
<p>所以可以通过这个“Class对象”操作这个类，要使用一个类，首先要加载类，加载完类后，，在堆内存中，就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象就包含了完整的类结构信息，可以通过这个对象知道类的结构，这个对象就像一面镜子，透过这面镜子可以看到类的结构。所以，形象的称为反射，因此：Clas对象是反射机制的核心，可以通过“Class对象”调用这个类的所有属性，方法，这个就可以加载，运行相关的类</p>
<p>反射的定义： 主要是指程序可以访问、检测和修改它本身状态或行为的一种能力</p>
<p>是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.，java类中的各种成分映射成一个个的Java对象 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line">Class.forName(<span class="string">&quot;package1.ClassName&quot;</span>);</span><br><span class="line"><span class="comment">//这个方法可以在运行时在决定加载是什么样的类字符串传入什么类，就在什么类，完全与源码无关，这就是动态性，反射实现了“运行时加载、探知、使用”而编译期间完成未知的类，</span></span><br></pre></td></tr></table></figure>

<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>定义：是反射(Reflection)的根源，针对任何要动态加载，运行的类，Class类表示Java中类型的本身</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Class类的对象的方法如下所示</span></span><br><span class="line"><span class="comment">/*getClass()返回包含类表示所有的公共类和由此表示类的成员接口的对象类的数组*/</span></span><br><span class="line">Class c1=user.getClass();</span><br><span class="line">System.out.println(c1);</span><br><span class="line"><span class="comment">/*.class语法*/</span></span><br><span class="line">Class c2=User.class;</span><br><span class="line">System.out.println(c2);</span><br><span class="line"><span class="comment">/*Class.forName()方法*/</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.bdqn.demo1.User&quot;</span>);</span><br><span class="line">System.out.println(c3);</span><br><span class="line"><span class="comment">/*每个类只有会一个Class对象，因此c1,c2,c3实际指向的是同一个对象*/</span></span><br></pre></td></tr></table></figure>

<h2 id="反射机制的优缺点"><a href="#反射机制的优缺点" class="headerlink" title="反射机制的优缺点"></a>反射机制的优缺点</h2><p>优点：可以让程序在运行时加载编译期间完全未知类，让程序更加灵活，更加开放，</p>
<p>缺点：是会大大降低程序执行的效率</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bdqn.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bdqn.demo1.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: duan.rong.gui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022/3/31 11:21:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 主方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * 类描述：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test00</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*创建包的路径*/</span></span><br><span class="line">        String path=<span class="string">&quot;com.bdqn.demo1.User&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = Class.forName(path);</span><br><span class="line">            <span class="comment">/*获取当前系统时间*/</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">reflectStart1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            User user1=(User) aClass.newInstance();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> aClass.getDeclaredMethod(<span class="string">&quot;setUname&quot;</span>,String.class);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++)&#123;</span><br><span class="line">                method1.invoke(user1,<span class="string">&quot;王晓明&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*执行结束时间*/</span></span><br><span class="line">            <span class="type">long</span> reflectEnd1=System.currentTimeMillis();</span><br><span class="line">            <span class="type">long</span> objectStart1=System.currentTimeMillis();</span><br><span class="line">            User user2=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++)&#123;</span><br><span class="line">                user2.setUname(<span class="string">&quot;王晓明&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> objectEnd1=System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;反射机制执行时间:&quot;</span>+(reflectEnd1-reflectStart1));</span><br><span class="line">            System.out.println(<span class="string">&quot;普通方法执行时间:&quot;</span>+(objectEnd1-objectStart1));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="反射机制的常见操作"><a href="#反射机制的常见操作" class="headerlink" title="反射机制的常见操作"></a>反射机制的常见操作</h2><p>定义：实际上就是Class对象常用方法的使用，，一般有以下几种常见操作：动态加载类，动态获取类的信息(属性、方法、构造器)、动态构造对象、动态调用类和对象的任意方法、动态调用和处理属性、获取泛型信息、处理注解。</p>
<h3 id="反射机制中常见操作中设计的类"><a href="#反射机制中常见操作中设计的类" class="headerlink" title="反射机制中常见操作中设计的类"></a>反射机制中常见操作中设计的类</h3><table>
<thead>
<tr>
<th>类名</th>
<th>类的作用</th>
</tr>
</thead>
<tbody><tr>
<td>Class</td>
<td>代表类的结构信息</td>
</tr>
<tr>
<td>Method</td>
<td>代表方法的结构信息</td>
</tr>
<tr>
<td>Field</td>
<td>代表属性的结构信息</td>
</tr>
<tr>
<td>Constructor</td>
<td>代表构造方法的结构信息</td>
</tr>
<tr>
<td>Annotation</td>
<td>代表注解的结构信息</td>
</tr>
</tbody></table>
<h3 id="操作构造方法-Constructor类"><a href="#操作构造方法-Constructor类" class="headerlink" title="操作构造方法(Constructor类)"></a>操作构造方法(Constructor类)</h3><p>利用getConstructor()方法返回Constructor对象</p>
<ul>
<li>Constructor&lt;?&gt;[] getConstructors():返回包含一个Constructor对象的反射数组，由此表示类的公共的构造类对象</li>
<li>Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes):返回一个Constructor对象的，该对象表示类的指定的公共类的方法</li>
<li>Constructor&lt;?&gt;[] getDeclaredConstructors()：返回一个反映Constructor对象的类，声明的所有Constructor对象的数组类</li>
<li><T>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes):返回一个Constructor对象，该对象反映Constructor对象表示的类或接口的指定类的函数</li>
</ul>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>String getName()</td>
<td>以字符串形式返回此构造方法的名称</td>
</tr>
<tr>
<td>类&lt;?&gt;[] getParamterTypes()</td>
<td>返回一个类对象的数组，类以声明顺序表示该对象的可执行文件的形参类型</td>
</tr>
<tr>
<td>类&lt;?&gt;[] getExcepitonTypes()</td>
<td>返回一个类对象的数组，类表示由该对象的底层可执行文件声明的异常类型</td>
</tr>
<tr>
<td>T newInstance(Object… initargs)</td>
<td>使用此Constructor对象表示的构造方法，使用指定的初始化参数创建和初始化构造方法的声明类的新实例</td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>返回由该对象表示的可执行文件的Java语言的modifiers</td>
</tr>
<tr>
<td>boolean isVarArgs()</td>
<td>如果这个可执行文件带有可变数量的参数，则返回true，否则返回false</td>
</tr>
</tbody></table>
<p>getModifiers()方法的返回值是Modifier类信息，在该类中提供了一系列用来解析修饰符的静态方法，既可以查看是否包含被指定的修饰符修饰，也可以以字符串的形式获得所有修饰符、</p>
<p>Modifier的常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>isAbstract(int mod)</td>
<td>如果int 型参数包含abstract修饰符，则返回true，否则返回false</td>
</tr>
<tr>
<td>isFinal(int mod)</td>
<td>如果int 型参数包含final修饰符，则返回true，否则返回false</td>
</tr>
<tr>
<td>isInterface(int mode)</td>
<td>如果int 型参数包含interface修饰符，则返回true，否则返回false</td>
</tr>
<tr>
<td>isNative(int mod)</td>
<td>如果int 型参数包含native修饰符，则返回true，否则返回false</td>
</tr>
<tr>
<td>isPrivate(int mod)</td>
<td>如果int 型参数包含private修饰符，则返回true，否则返回false</td>
</tr>
<tr>
<td>isProtected(int  mod)</td>
<td>如果int 型参数包含protected修饰符，则返回true，否则返回false</td>
</tr>
<tr>
<td>isPublic(int mod)</td>
<td>如果int 型参数包含public修饰符，则返回true，否则返回false</td>
</tr>
<tr>
<td>isStaitc(int mod)</td>
<td>如果int 型参数包含static修饰符，则返回true，否则返回false</td>
</tr>
<tr>
<td>isSynschronized(int mod)</td>
<td>如果int 型参数包含Sysnchronized修饰符，则返回true，否则返回false</td>
</tr>
<tr>
<td>String toString(int mod)</td>
<td>返回描述指定修饰符中的访问修饰符标志的字符串</td>
</tr>
</tbody></table>
<h3 id="操作属性Field类"><a href="#操作属性Field类" class="headerlink" title="操作属性Field类"></a>操作属性Field类</h3><p>构造方法</p>
<p>Field  getDeclaredField(String name) 返回一个Field对象，它反映此表示的类或接口的指定已声明字段 类对象。  </p>
<p>Field[]  getDeclaredFields()返回的数组 Field对象反映此表示的类或接口声明的所有字段 类对象。</p>
<p>Field  getField(String name) 返回一个 Field对象，它反映此表示的类或接口的指定公共成员字段类对象。 </p>
<p>Field[]  getFields()  返回包含一个数组 Field对象反射由此表示的类或接口的所有可访问的公共字段类对象。 </p>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean getBoolean(Object obj)</td>
<td>获取静态或实例boolean型字段值</td>
</tr>
<tr>
<td>byte getByte(Object obj)</td>
<td>获取静态或实例的byte型字段值</td>
</tr>
<tr>
<td>char getChar(Object obj)</td>
<td>获取静态或实例的char型字段值，或者通过扩展转换获得可转换成char型的里一个值</td>
</tr>
<tr>
<td>double getDouble(Object obj)</td>
<td>获取静态或实例的double型字段值,或者通过扩展转换成为另一个型double值</td>
</tr>
<tr>
<td>int getInt(Object obj)</td>
<td>获取静态或实例的int型字段值,或者通过扩展转换成为另一个型int值</td>
</tr>
<tr>
<td>float getFloat(Object obj)</td>
<td>获取静态或实例的float型字段值,或者通过扩展转换成为另一个型float值</td>
</tr>
<tr>
<td>long getLong(Object obj)</td>
<td>获取静态或实例的long型字段值,或者通过扩展转换成为另一个型long值</td>
</tr>
<tr>
<td>short getShort(Object obj)</td>
<td>获取静态或实例的short型字段值,或者通过扩展转换成为另一个型short值</td>
</tr>
<tr>
<td>Class&lt;?&gt; getType()</td>
<td>返回一个类对象，标识了由此表示的字段的声明类型Fileld对象</td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>返回由该Field对象表示的字段的Java语言修饰符，作为整数</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回由该FIeld对象表示的字段的名称</td>
</tr>
<tr>
<td>void setBoolean(Object obj,boolean b)</td>
<td>设置一个boolean型字段到指定的对象上</td>
</tr>
<tr>
<td>void setByte(Object obj,byte byte)</td>
<td>设置一个byte型字段到指定的对象上</td>
</tr>
<tr>
<td>void setChar(Object obj,Char char)</td>
<td>设置一个char型字段到指定的对象上</td>
</tr>
<tr>
<td>void setDouble(Object obj,double d)</td>
<td>设置一个double型字段到指定的对象上</td>
</tr>
<tr>
<td>void setFloat(Object obj,float float)</td>
<td>设置一个float型字段到指定的对象上</td>
</tr>
<tr>
<td>void setInt(Object obj,int i)</td>
<td>设置一个int型字段到指定的对象上</td>
</tr>
<tr>
<td>void setLong(Object obj,long l)</td>
<td>设置一个Long型字段到指定的对象上</td>
</tr>
<tr>
<td>void setShort(Object obj,short s)</td>
<td>设置一个short型字段到指定的对象上</td>
</tr>
</tbody></table>
<h3 id="操作方法-Mothod"><a href="#操作方法-Mothod" class="headerlink" title="操作方法(Mothod)"></a>操作方法(Mothod)</h3><p>构造方法</p>
<ul>
<li>Method  getDeclaredMethod(String name,  类… parameterTypes) 返回一个 方法对象，它反映此表示的类或接口的指定声明的方法类对象</li>
<li>Method[] getDeclaredMethods()返回包含一个数组方法对象反射的类或接口的所有声明的方法，通过此表示类对象，包括公共，保护，默认（包）访问和私有方法，但不包括继承的方法。</li>
<li>Method getMethod(String name,  类… parameterTypes)返回一个方法对象，它反映此表示的类或接口的指定公共成员方法类对象。  </li>
<li>Method[] getMethods()返回包含一个数组方法 对象反射由此表示的类或接口的所有公共方法类对象，包括那些由类或接口和那些从超类和超接口继承的声明。</li>
</ul>
<p>常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>String getName()</td>
<td>返回由此方法对象表示的方法的名称，作为String返回</td>
</tr>
<tr>
<td>int getParameterCount()</td>
<td>返回由此对象表示的可执行文件的形式参数(无论是显示声明，还是隐式声明)的数量</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getParameterTypes()</td>
<td>返回一个类对象的数组，以声明顺序表示由该对象表示的可执行文件的形式参数类型</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getExceptionTypes</td>
<td>返回一个类对象的数组，他表示由该对象表示的底层可执行文件声明的异常类型</td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>返回由该对象表示的可执行文件的Java语言修饰符</td>
</tr>
<tr>
<td>Class&lt;?&gt; getReturnType()</td>
<td>返回一个类对象，他表示由该方法对象表示的方法的返回类型</td>
</tr>
<tr>
<td>boolean isVarArgs()</td>
<td>如果这个可执行文件被宣布为带有可变数量的参数，则返回true，否则返回false</td>
</tr>
<tr>
<td>Object invoke(Object obj,Object… args)</td>
<td>在具有指定参数的方法对象上调用此方法对象表示的底层方法</td>
</tr>
</tbody></table>
<h2 id="Annotation注解功能"><a href="#Annotation注解功能" class="headerlink" title="Annotation注解功能"></a>Annotation注解功能</h2><h3 id="定义Annotation类型"><a href="#定义Annotation类型" class="headerlink" title="定义Annotation类型"></a>定义Annotation类型</h3><p>定义：使用的关键字为@interface，这个关键的隐含意思是继承java.lang.annotation.Annotaition接口</p>
<p>包含的成员类型</p>
<ul>
<li>可用的成员类型：String、Class、primitive、enumerated和annotation，以及所列类型的数组</li>
<li>成员名称：如果只包含一个成员，则通常命名为value，再定成员时，也可以设置成员的默认值</li>
</ul>
<p>通过@Target可以设置Annotation类型适用的程序元素种类，如果不设置@Target，则表示适用于所有程序元素</p>
<p>通过@Retention可以设置Annotation的有效范围</p>
<h3 id="访问Annotation信息"><a href="#访问Annotation信息" class="headerlink" title="访问Annotation信息"></a>访问Annotation信息</h3><ul>
<li>boolean isAnnotationPresent(类&lt;? extends Annottion&gt; annotationClass):如果此元素上存在指定类型的注释，则返回true，否则返回false</li>
<li><T extends Annotation> T getAnnotation(类<T> annotationClass):返回该元素的注解；否则返回null类型的注解</li>
<li>Annotation[] getAnnotations():返回此元素上存在的注释</li>
</ul>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><p>定义：代码的特殊标记：</p>
<p>常见的注解：@Override、@author、@date</p>
<h3 id="注解的使用场所"><a href="#注解的使用场所" class="headerlink" title="注解的使用场所"></a>注解的使用场所</h3><ol>
<li>生成文档相关的注解</li>
<li>编译时进行格式检查</li>
<li>跟踪代码依赖性，实现替代配置文件功能</li>
</ol>
<h3 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h3><ol>
<li>自定义注解声明为@interface</li>
<li>内部定义成员，通常使用value表示</li>
<li>可以指定成员的默认值，使用default定义</li>
<li>如果自定义的注解没有注解，表明这是一个标识作用</li>
</ol>
<p>注意事项</p>
<ol>
<li>如果注解有成员，在使用注解时，需要指明成员的值</li>
<li>自定义注解必须配上注解的信息处理流程(使用反射)才有意义</li>
</ol>
<p>代码示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bdqn.demo.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: duan.rong.gui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/29 8:48:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 定义注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">/*如果是参数列表的话，一般定义为value，</span></span><br><span class="line"><span class="comment">    * 默认则为default</span></span><br><span class="line"><span class="comment">    * 没有成员定义的一般称之为标记</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bdqn.demo.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: duan.rong.gui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/29 8:48:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 定义注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">/*如果是参数列表的话，一般定义为value，</span></span><br><span class="line"><span class="comment">    * 默认则为default</span></span><br><span class="line"><span class="comment">    * 没有成员定义的一般称之为标记</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="jdk的元注解"><a href="#jdk的元注解" class="headerlink" title="jdk的元注解"></a>jdk的元注解</h3><p>元注解的分类</p>
<ol>
<li><p>@Retention</p>
<p>定义： 声明创建一个注解的时候，指定这个被声明创建的注解可以保留多长时间。它里边有一个RetentionPolicy类型的value变量，该变量的值只有三个，不同的值代表不同的保留规则。声明生命周期 </p>
<ol>
<li>RetentionPolicy.SOURCE<ul>
<li>在源文件中有效,编译器直接会丢弃这种方式修饰的注解</li>
<li>也称之为:“源文件保留”</li>
</ul>
</li>
<li>RetentionPolicy.CLASS<ul>
<li>在class文件中有效,当运行java程序时,JVM不会保留这种方式修饰的注解</li>
<li>也称之为:“class保留”</li>
<li>RetentionPolicy.CLASS是@Retention中的默认值</li>
</ul>
</li>
<li>RetentionPolicy.RUNTIME<ul>
<li>在程序运行时也有效,当运行java程序时,JVM会保留这种方式修饰的注解可以通过反射获取相关的信息</li>
<li>注意: 修饰为这种方式的注解我们可以通过反射来获取到该注解</li>
<li>也称之为: “运行时保留”</li>
</ul>
</li>
</ol>
</li>
<li><p>@Target</p>
<ol>
<li>包含了一个 ElementType[] 类型的成员变量,变量名为value <ol>
<li>ElementType[]是一个枚举类</li>
</ol>
</li>
<li>ElementType枚举类中枚举值有以下7种<ol>
<li>CONSTRUCTOR<ul>
<li>用于修饰构造器</li>
</ul>
</li>
<li>FIELD<ul>
<li>用于修饰域(也就是属性(也就是成员变量))</li>
</ul>
</li>
<li>LOAL_VARIABLE (variable 中文 变量)<ul>
<li>用于修饰局部变量</li>
</ul>
</li>
<li>METHOD<ul>
<li>用于修饰方法</li>
</ul>
</li>
<li>PACKAGE<ul>
<li>用于修饰包</li>
</ul>
</li>
<li>PARAMETER( parameter 中文 参数)<ul>
<li>用于修饰参数</li>
</ul>
</li>
<li>TYPE<ul>
<li>用于修饰类,接口(包括注解类型,枚举类的声明</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>@Documented只能用于修饰现有的注解</p>
<ul>
<li><p>被@Documented元注解修饰的注解将在被javadoc工具提取成文档时保留下来</p>
<p>默认情况下,Javadoc生成文档时不会保留注解的,除非此注解使用@Documented元注解修饰</p>
</li>
<li><p>注意:使用@Documented元注解修饰的注解的声明周期必须设置为”运行时保留”,也就是必须设置@Retention的值为RetentionPolicy.RUNTIME</p>
</li>
</ul>
</li>
<li><p>@Inherited</p>
<p>@Inherited元注解只能用于修饰现有的注解</p>
<ul>
<li><p>被@Inherited元注解修饰的注解将具有继承性</p>
<p>这里的具有继承性指的是: 如果某一个类使用了被@Inherited修饰的注解,那么其子类也将自动具有该注解</p>
<p>那么具体的我们如何验证其子类是否真正的继承了该注解,我们可以将这个注解的生命周期设置为”运行时保留”,然后再通过反射去获得修饰子类的注解,然后去判断</p>
</li>
</ul>
</li>
<li><p>@Repeatable</p>
<p>@Repeatable注解是用来标注一个注解在同一个地方可重复使用的一个注解，比如说你定义了一个注解，如果你的注解没有标记</p>
</li>
</ol>
<p>什么是元注解</p>
<p>对现有的注解进行解释说明的注解</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">RainGrd</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/21/Java/">http://example.com/2023/07/21/Java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">RainGrd Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/07/21/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">RainGrd</div><div class="author-info__description">ѧϰ����������õ�Ͷ��</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">关系：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%96%E7%95%8C"><span class="toc-number">1.1.2.</span> <span class="toc-text">面向对象的世界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">1.1.3.</span> <span class="toc-text">如何定义类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.</span> <span class="toc-text">this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%8C%87%E5%90%91"><span class="toc-number">1.2.1.</span> <span class="toc-text">this的多种指向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFthis"><span class="toc-number">1.2.2.</span> <span class="toc-text">什么是this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">this的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">什么是构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.3.2.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">构造方法的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.3.4.</span> <span class="toc-text">构造方法的重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.4.</span> <span class="toc-text">static 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E5%92%8C%E5%AF%BC%E5%8C%85"><span class="toc-number">1.5.</span> <span class="toc-text">包和导包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">1.6.</span> <span class="toc-text">访问权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#public"><span class="toc-number">1.6.1.</span> <span class="toc-text">public</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#default"><span class="toc-number">1.6.2.</span> <span class="toc-text">default</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#private"><span class="toc-number">1.6.3.</span> <span class="toc-text">private</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.7.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.8.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.9.</span> <span class="toc-text">super关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#super%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.9.1.</span> <span class="toc-text">super的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super%E4%B8%8Ethis%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.2.</span> <span class="toc-text">super与this关键字的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-number">1.10.</span> <span class="toc-text">方法的重写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E5%86%99"><span class="toc-number">1.10.1.</span> <span class="toc-text">什么是重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.10.2.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.10.3.</span> <span class="toc-text">重写的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99"><span class="toc-number">1.10.4.</span> <span class="toc-text">方法的重写规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.11.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81%EF%BC%9A"><span class="toc-number">1.11.1.</span> <span class="toc-text">什么是多态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">1.11.2.</span> <span class="toc-text">多态的作用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.11.3.</span> <span class="toc-text">多态的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.11.4.</span> <span class="toc-text">多态存在的三个必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.11.5.</span> <span class="toc-text">小知识点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">1.12.</span> <span class="toc-text">重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E8%BD%BD"><span class="toc-number">1.12.1.</span> <span class="toc-text">什么是重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">1.12.2.</span> <span class="toc-text">重载的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.12.3.</span> <span class="toc-text">重载的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.12.4.</span> <span class="toc-text">重写与重载之间的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.13.</span> <span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.14.</span> <span class="toc-text">抽象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.15.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.15.1.</span> <span class="toc-text">接口的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">1.15.2.</span> <span class="toc-text">接口的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.15.3.</span> <span class="toc-text">接口与类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.15.4.</span> <span class="toc-text">抽象类与接口的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.16.</span> <span class="toc-text">Object(对象)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#equals%E5%92%8C"><span class="toc-number">1.17.</span> <span class="toc-text">equals和&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Instanceof%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.18.</span> <span class="toc-text">Instanceof关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.19.</span> <span class="toc-text">面向对象设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-number">1.19.1.</span> <span class="toc-text">单一职责原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-number">1.19.2.</span> <span class="toc-text">开闭原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">1.19.3.</span> <span class="toc-text">里氏代换原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">1.19.4.</span> <span class="toc-text">依赖倒换原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-number">1.19.5.</span> <span class="toc-text">接口隔离原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">1.19.6.</span> <span class="toc-text">合成复用原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99"><span class="toc-number">1.19.7.</span> <span class="toc-text">迪米特法则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.20.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.20.1.</span> <span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.20.2.</span> <span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.20.3.</span> <span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.20.4.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UML%E7%B1%BB%E5%9B%BE"><span class="toc-number">1.21.</span> <span class="toc-text">UML类图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96-Generalization"><span class="toc-number">1.21.1.</span> <span class="toc-text">泛化(Generalization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-Realization"><span class="toc-number">1.21.2.</span> <span class="toc-text">实现(Realization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94-Association"><span class="toc-number">1.21.3.</span> <span class="toc-text">关联(Association)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88-Aggregation"><span class="toc-number">1.21.4.</span> <span class="toc-text">聚合(Aggregation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88-Composition"><span class="toc-number">1.21.5.</span> <span class="toc-text">组合(Composition)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96-Dependency"><span class="toc-number">1.21.6.</span> <span class="toc-text">依赖(Dependency)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB%E7%9A%84%E5%BC%BA%E5%BC%B1%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.21.7.</span> <span class="toc-text">各种关系的强弱顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93"><span class="toc-number">2.</span> <span class="toc-text">Java基础类库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer"><span class="toc-number">2.1.</span> <span class="toc-text">Integer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8EString%E4%B9%8B%E9%97%B4%E7%9A%84%E8%A3%85%E6%8D%A2"><span class="toc-number">2.2.</span> <span class="toc-text">基本数据类型、包装类与String之间的装换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">单元测试方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Character%E7%B1%BB"><span class="toc-number">2.4.</span> <span class="toc-text">Character类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number%E7%B1%BB"><span class="toc-number">2.5.</span> <span class="toc-text">Number类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-number">2.6.</span> <span class="toc-text">时间类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Date"><span class="toc-number">2.6.1.</span> <span class="toc-text">Date</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calendar"><span class="toc-number">2.6.2.</span> <span class="toc-text">Calendar</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java8-%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94java-time%E5%8C%85-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E7%B1%BB"><span class="toc-number">2.7.</span> <span class="toc-text">java8 新特性—java.time包 时间处理类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Instant%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.8.</span> <span class="toc-text">Instant类的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DateTimeFormatter"><span class="toc-number">2.9.</span> <span class="toc-text">DateTimeFormatter</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%89%80"><span class="toc-number">3.1.</span> <span class="toc-text">枚举的使用场所</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">枚举的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.3.</span> <span class="toc-text">使用枚举的注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-number">4.2.</span> <span class="toc-text">好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%A0%87%E8%AF%86"><span class="toc-number">4.3.</span> <span class="toc-text">常用的泛型标识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">4.4.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.5.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E6%9C%89%E7%95%8C%E9%99%90%E5%88%B6"><span class="toc-number">4.7.</span> <span class="toc-text">通配符和有界限制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">5.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.1.</span> <span class="toc-text">Collection接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.1.2.</span> <span class="toc-text">Collection的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">1.使用Iterator迭代器遍历集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-foreach%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">2.foreach遍历集合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.1.3.</span> <span class="toc-text">List接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.1.4.</span> <span class="toc-text">Set接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88"><span class="toc-number">5.2.</span> <span class="toc-text">Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">5.2.2.</span> <span class="toc-text">常用类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="toc-number">5.3.</span> <span class="toc-text">Java集合框架体系图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">6.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">6.1.</span> <span class="toc-text">异常处理机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.</span> <span class="toc-text">异常类的层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%EF%BC%9A"><span class="toc-number">6.3.</span> <span class="toc-text">常见的异常：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%8F%8A%E5%85%B6%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">6.5.</span> <span class="toc-text">异常类及其主要方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-number">6.5.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-number">6.5.2.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8throw%E8%AF%AD%E5%8F%A5%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">6.6.</span> <span class="toc-text">使用throw语句抛出异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%B5%81"><span class="toc-number">7.</span> <span class="toc-text">Java流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">7.1.</span> <span class="toc-text">Java流的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">7.2.</span> <span class="toc-text">Java输入&#x2F;输出常用类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%B3%BB%E7%BB%9F%E6%B5%81"><span class="toc-number">7.3.</span> <span class="toc-text">Java系统流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">7.4.</span> <span class="toc-text">Java字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81-InputStream"><span class="toc-number">7.4.1.</span> <span class="toc-text">字节输入流(InputStream)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81-outputStream"><span class="toc-number">7.4.2.</span> <span class="toc-text">字节输出流(outputStream)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">7.4.3.</span> <span class="toc-text">字节数组输入流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">7.4.4.</span> <span class="toc-text">字节数组输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">7.4.5.</span> <span class="toc-text">文件字节输入流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">7.4.6.</span> <span class="toc-text">文件字节输出流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">7.5.</span> <span class="toc-text">Java字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">7.5.1.</span> <span class="toc-text">字符输入流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">7.5.2.</span> <span class="toc-text">字符输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">7.5.3.</span> <span class="toc-text">字符文件输入流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">7.5.4.</span> <span class="toc-text">字符文件输出流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%B5%81%E5%AF%B9%E6%AF%94"><span class="toc-number">7.6.</span> <span class="toc-text">Java输入&#x2F;输出流对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.6.1.</span> <span class="toc-text">字节流和字符流的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8C%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">7.6.2.</span> <span class="toc-text">区分输入流和输出流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">7.7.</span> <span class="toc-text">带缓存的输入&#x2F;输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BufferedInputStream"><span class="toc-number">7.7.1.</span> <span class="toc-text">BufferedInputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BufferedOutpuStream"><span class="toc-number">7.7.2.</span> <span class="toc-text">BufferedOutpuStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BufferedReader"><span class="toc-number">7.7.3.</span> <span class="toc-text">BufferedReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BufferedWriter"><span class="toc-number">7.7.4.</span> <span class="toc-text">BufferedWriter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">7.8.</span> <span class="toc-text">基本数据类型输入&#x2F;输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DataInputStream"><span class="toc-number">7.8.1.</span> <span class="toc-text">DataInputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataOutputStream"><span class="toc-number">7.8.2.</span> <span class="toc-text">DataOutputStream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zip%E5%8E%8B%E7%BC%A9%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">7.9.</span> <span class="toc-text">zip压缩输入&#x2F;输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#zipOutputStream"><span class="toc-number">7.9.1.</span> <span class="toc-text">zipOutputStream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZipInputStream"><span class="toc-number">7.10.</span> <span class="toc-text">ZipInputStream</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#File%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">File类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-3"><span class="toc-number">8.1.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-2"><span class="toc-number">8.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B8%B8%E9%87%8F"><span class="toc-number">8.3.</span> <span class="toc-text">File类中的常用常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">8.4.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8File%E7%B1%BB%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.5.</span> <span class="toc-text">使用File类注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-number">9.</span> <span class="toc-text">数据库操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jdbc%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">9.1.</span> <span class="toc-text">jdbc连接数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dirver%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.2.</span> <span class="toc-text">Dirver接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DriverManager"><span class="toc-number">9.3.</span> <span class="toc-text">DriverManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conneciton"><span class="toc-number">9.4.</span> <span class="toc-text">Conneciton</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Statement"><span class="toc-number">9.5.</span> <span class="toc-text">Statement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PrepatedStatement"><span class="toc-number">9.6.</span> <span class="toc-text">PrepatedStatement</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">9.6.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResultSet"><span class="toc-number">9.7.</span> <span class="toc-text">ResultSet</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">10.1.</span> <span class="toc-text">相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F"><span class="toc-number">10.1.1.</span> <span class="toc-text">程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6"><span class="toc-number">10.1.2.</span> <span class="toc-text">软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">10.1.3.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.1.4.</span> <span class="toc-text">线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%87%8C%E9%9D%A2%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.2.</span> <span class="toc-text">Java里面的多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%B1%BB-Thread"><span class="toc-number">10.2.1.</span> <span class="toc-text">线程类(Thread)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84-ThreadGroup"><span class="toc-number">10.2.2.</span> <span class="toc-text">线程组(ThreadGroup)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">10.3.</span> <span class="toc-text">多线程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.3.1.</span> <span class="toc-text">继承Thread类创建多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.3.2.</span> <span class="toc-text">实现Runnable接口创建多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">10.3.3.</span> <span class="toc-text">两种实现方法的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">10.4.</span> <span class="toc-text">线程的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="toc-number">10.4.1.</span> <span class="toc-text">线程基本状态转换图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E7%8A%B6%E6%80%81"><span class="toc-number">10.4.2.</span> <span class="toc-text">新建状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81"><span class="toc-number">10.4.3.</span> <span class="toc-text">就绪状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="toc-number">10.4.4.</span> <span class="toc-text">运行状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81"><span class="toc-number">10.4.5.</span> <span class="toc-text">阻塞状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81"><span class="toc-number">10.4.6.</span> <span class="toc-text">终止状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">10.5.</span> <span class="toc-text">线程的调度与优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">10.5.1.</span> <span class="toc-text">线程的调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">10.5.2.</span> <span class="toc-text">线程的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">10.5.3.</span> <span class="toc-text">什么是线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F"><span class="toc-number">10.5.4.</span> <span class="toc-text">优先级整数常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">10.6.</span> <span class="toc-text">线程的控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.6.1.</span> <span class="toc-text">终止线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">10.6.2.</span> <span class="toc-text">测试线程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%91%E7%9C%A0"><span class="toc-number">10.6.3.</span> <span class="toc-text">线程的休眠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8F%92%E9%98%9F"><span class="toc-number">10.6.4.</span> <span class="toc-text">线程的插队</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%AE%A9%E6%AD%A5"><span class="toc-number">10.6.5.</span> <span class="toc-text">线程的让步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">10.7.</span> <span class="toc-text">多线程的互斥与同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%BB%E9%94%81"><span class="toc-number">10.7.1.</span> <span class="toc-text">线程的死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5"><span class="toc-number">10.7.2.</span> <span class="toc-text">多线程的互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">10.7.3.</span> <span class="toc-text">多线程的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">10.7.3.1.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%BC%8A%E7%AB%AF"><span class="toc-number">10.7.3.2.</span> <span class="toc-text">同步的好处和弊端</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock%E9%94%81"><span class="toc-number">10.8.</span> <span class="toc-text">Lock锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">10.9.</span> <span class="toc-text">Lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">11.1.</span> <span class="toc-text">网络通信协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">11.2.</span> <span class="toc-text">网络编程三要素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="toc-number">11.3.</span> <span class="toc-text">IP地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%92%8C%E5%8D%8F%E8%AE%AE"><span class="toc-number">11.4.</span> <span class="toc-text">端口和协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InetAddress"><span class="toc-number">11.5.</span> <span class="toc-text">InetAddress</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">11.6.</span> <span class="toc-text">UDP通信程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-number">11.6.1.</span> <span class="toc-text">UDP的通信原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UPD%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">11.6.2.</span> <span class="toc-text">UPD发送数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">11.6.3.</span> <span class="toc-text">UDP接收数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">11.7.</span> <span class="toc-text">TCP通信程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-number">11.7.1.</span> <span class="toc-text">TCP通信原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">11.7.2.</span> <span class="toc-text">TCP发送数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">11.7.3.</span> <span class="toc-text">TCP接收数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">12.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">12.1.</span> <span class="toc-text">反射机制的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class%E7%B1%BB"><span class="toc-number">12.2.</span> <span class="toc-text">Class类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">12.3.</span> <span class="toc-text">反射机制的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="toc-number">12.4.</span> <span class="toc-text">反射机制的常见操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E4%B8%AD%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%B1%BB"><span class="toc-number">12.4.1.</span> <span class="toc-text">反射机制中常见操作中设计的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-Constructor%E7%B1%BB"><span class="toc-number">12.4.2.</span> <span class="toc-text">操作构造方法(Constructor类)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%B1%9E%E6%80%A7Field%E7%B1%BB"><span class="toc-number">12.4.3.</span> <span class="toc-text">操作属性Field类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95-Mothod"><span class="toc-number">12.4.4.</span> <span class="toc-text">操作方法(Mothod)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Annotation%E6%B3%A8%E8%A7%A3%E5%8A%9F%E8%83%BD"><span class="toc-number">12.5.</span> <span class="toc-text">Annotation注解功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89Annotation%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.5.1.</span> <span class="toc-text">定义Annotation类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEAnnotation%E4%BF%A1%E6%81%AF"><span class="toc-number">12.5.2.</span> <span class="toc-text">访问Annotation信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">12.6.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%A8%E8%A7%A3"><span class="toc-number">12.6.1.</span> <span class="toc-text">什么是注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%89%80"><span class="toc-number">12.6.2.</span> <span class="toc-text">注解的使用场所</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">12.6.3.</span> <span class="toc-text">如何自定义注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk%E7%9A%84%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">12.6.4.</span> <span class="toc-text">jdk的元注解</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/21/Java/" title="Java">Java</a><time datetime="2023-07-21T09:29:10.544Z" title="发表于 2023-07-21 17:29:10">2023-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/21/hello-world/" title="Hello World">Hello World</a><time datetime="2023-07-21T09:26:10.486Z" title="发表于 2023-07-21 17:26:10">2023-07-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By RainGrd</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>